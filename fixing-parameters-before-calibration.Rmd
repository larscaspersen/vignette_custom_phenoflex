---
title: "Fixing Parameters Before Calibration"
output: distill::distill_article
bibliography: vignette_phenoflex.bib
csl: elsevier-harvard-modifed.csl
---

Fixing model parameters to default values and excluding them from the model calibration is relatively easy in PhenoFlex. This is thanks to the modular structure of the `chillR::phenologyFitter()` function. Modifying the input for the `modelfn` argument does the trick. By default it is set to `PhenoFlex_GDHwrapper`. This is the name of a function in the chillR package. The help page of the `chillR::phenologyFitter()` function says, that the modelfn argument is a *"[...] Model function which computes the index in 'temperatures' at which blooming occures. It must have as first argument a data frame with at least the two columns 'Temp' and 'JDays' for one season, see 'SeasonList'. It can have further arguments which can be passed via '...'. The 'modelfn' must return a single numeric value for the predicted bloom JDay for that season. 'NA' is an allowed return value if no blooming occures in that season. The default is the PhenoFlex with GDH as heat accumulation. Alternative is PhenoFlex_GAUSSwrapper with GAUSSian heat accumulation. But this function can also be user defined."* 
In essence, the function needs to be able to calculate the bloom date for a data.frame with temperature data for one season (argument `x`) and for a paticular set of model parameters (argument `par`). Here is how the default function looks like: 

```{r}
chillR::PhenoFlex_GDHwrapper
```

As you can see, the `PhenoFlex_GDHwrapper` wrapper is a relatively simple funciton. It takes `x` and `par` as inputs. `x` should be of the same format as tge output of the `chillR::genSeasonList()` function, it produces a list of data.frames, each data.frame has three columns: 'Temp', 'JDay' and 'Year'. `par` is a numeric vector with twelve entries, containing the PhenoFlex model parameters. Pay attention, that the order of parameters is correct, otherwise the function may not work or produce funny results. The first par of the code ensures that temperatures of the heat submodel make sense, the base temperature $T_b$ must be lower than optimal temperature $T_u$ and secondly, $T_u$ should not be larger than the critical temperature $T_c$. The next part of the code inserts the model parameters and the temperature data into PhenoFlex. PhenoFlex returns the bloomindex, this is not the bloom date but indicates at which row of the temperature data.frame `x` the accumulated heat exceeds the heat requirement $z_c$. The last part of the code calculates the bloom date, it has a routine what to do when the accumulated heat never exceeds $z_c$ (it returns an `NA` to the `phenologyFitter()` function) or it calculates the Julian Day (with digits). The bloom date calculation looks at first glance a bit complicated, but it accounts for the hour when the requirement is met. When it is met at noon at 12:00, it returns the Julian Day without alteration. If it is earlier, it subtracts a fraction and if it is later than noon it adds a fraction. 

## Customizing the wrapper function

The requirements on the wrapper function supplied in `modelfn` are relatively loose. It was never specified, for example, how many parameters need to be supplied and in which order. When we want to exclude some model parameters from calibration, maybe because we noted that they contribute relatively little to the model performance, then we can adjust how we insert the model parameters of `par` in the `chillR::PhenoFlex()` function. 

Here is an example with $T_c$ fixed at 36°C. Now par should have only 11 entries, because we fixed Tc. Pay attention, that you incert the fixed parameters at the right position or correct the indices in the later code, so that the parameters are assigned correctly in the PhenoFlex function call. You can of course fix more model parameters, if you want to. Also, make sure that you remove the fixed parameter from `par.guess` and the search ranges when running the `phenologyFitter()` function.

```{r}
PhenoFlex_GDHwrapper_fixed <- function (x, par, Tc = 36) 
{
  par <- c(par[1:9], Tc, par[10:11])
    if (par[4] <= par[11]) 
        return(NA)
    if (par[10] <= par[4]) 
        return(NA)
    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), 
        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], 
        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], 
        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex
    if (bloomindex == 0) 
        return(NA)
    JDay <- x$JDay[bloomindex]
    JDaylist <- which(x$JDay == JDay)
    n <- length(JDaylist)
    if (n == 1) 
        return(JDay)
    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))
}

```


We have adjusted the wrapper function! And now what? Next time we want to calibrate the model with $T_c$ fixed at 36°C (or any other value), we can use `PhenoFlex_GDHwrapper_fixed` as an argument for `modelfn` when running the `chillR::phenologyFitter()` function. Just make sure that you remove $T_c$ from the `par.guess`, `lower` and `upper` argument, when running the function. Here is an example code from the help page of the `chillR::phenologyFitter()` function, that I modified to keep $T_c$ fixed at 36°C. 

```{r, eval=FALSE}
data(KA_weather)
data(KA_bloom)
hourtemps <- stack_hourly_temps(KA_weather, latitude=50.4)
SeasonList <- genSeasonList(hourtemps$hourtemps, years=c(2007,2008))
#remove Tc from par.guess, upper and lower
#--> only 11 parameters to estimate
#       yc    zc   s1  Tu  E0      E1      A0      A1           Tf Tb slop  
par <- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 4, 1.6)
upper <- c(41, 200, 1, 30, 4000, 10000, 7000, 6.e13, 10, 10, 50)
lower <- c(38, 180, 0.1, 0, 3000, 9000, 6000, 5.e13, 0, 0, 0.05)
X <- phenologyFitter(par.guess=par, bloomJDays=KA_bloom$pheno[c(24,25)], 
  SeasonList=SeasonList, lower=lower, upper=upper,
  control=list(smooth=FALSE, verbose=TRUE, maxit=10, nb.stop.improvement=5))
summary(X)
plot(X)

```

It is quite convenient, that we choose to have the fixed parameter as an additional model argument. If we later change our mind and want to keep $T_c$ fixed at 30°C instead of the default 36°C, we only need to add that information in the function call of the `chillR::phenologyFitter()`. If we forgot to specify the default value as an argument of the function, we would be forced to either change the code specifying the `modelfn` function or create an alternative version. Quite messy. But because we kept Tc as a function argument, with a default value of 36, we can pass different values for $T_c$ via the `chillR::phenologyFitter()` function. We can do that, thanks to the magic of the `...` argument of the `chillR::phenologyFitter()`. As far as I understand it, the `...` argument takes any named or unnamed additional argument, that is not specified when the function is defined. And the fitter function is coded in a way, that all these additional arguments are passed on to the `modelfn` function. Just make sure that you name the argument correctly, so that the function can assign it to the function specified in `modelfn`.

```{r, eval=FALSE}
data(KA_weather)
data(KA_bloom)
hourtemps <- stack_hourly_temps(KA_weather, latitude=50.4)
SeasonList <- genSeasonList(hourtemps$hourtemps, years=c(2007,2008))
#remove Tc from par.guess, upper and lower
#--> only 11 parameters to estimate
#       yc    zc   s1  Tu  E0      E1      A0      A1           Tf Tb slop  
par <- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 4, 1.6)
upper <- c(41, 200, 1, 30, 4000, 10000, 7000, 6.e13, 10, 10, 50)
lower <- c(38, 180, 0.1, 0, 3000, 9000, 6000, 5.e13, 0, 0, 0.05)
X <- phenologyFitter(par.guess=par, bloomJDays=KA_bloom$pheno[c(24,25)], 
  SeasonList=SeasonList, lower=lower, upper=upper,
  Tc = 30,
  control=list(smooth=FALSE, verbose=TRUE, maxit=10, nb.stop.improvement=5))
summary(X)
plot(X)

```

