{
  "articles": [
    {
      "path": "fixing-parameters-before-calibration.html",
      "title": "Fixing Parameters Before Calibration",
      "author": [],
      "contents": "\r\nFixing model parameters to default values‚Äîso that they are excluded from calibration‚Äîis relatively straightforward in PhenoFlex, thanks to the modular design of the chillR::phenologyFitter() function. The key is to modify the modelfn argument, which by default is set to PhenoFlex_GDHwrapper, a function included in the chillR package.\r\nAccording to the help page for chillR::phenologyFitter(), the modelfn must be a ‚Äú[‚Ä¶] model function which computes the index in ‚Äòtemperatures‚Äô at which blooming occures. It must have as first argument a data frame with at least the two columns ‚ÄòTemp‚Äô and ‚ÄòJDays‚Äô for one season, see ‚ÄòSeasonList‚Äô. It can have further arguments which can be passed via ‚Äò‚Ä¶‚Äô. The ‚Äòmodelfn‚Äô must return a single numeric value for the predicted bloom JDay for that season. [‚Ä¶]‚Äù\r\nIn short, the model function must calculate the bloom date for a data.frame x (with seasonal temperature data), given a specific parameter set par.\r\nHere‚Äôs how the default wrapper function looks:\r\n\r\n\r\nchillR::PhenoFlex_GDHwrapper\r\n\r\nfunction (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n<bytecode: 0x0000029fb326b3c8>\r\n<environment: namespace:chillR>\r\n\r\nThe function is relatively simple. It accepts:\r\nx: a single-season data.frame (like those from chillR::genSeasonList()), with columns ‚ÄòTemp‚Äô, ‚ÄòJDay‚Äô and ‚ÄòYear‚Äô.\r\npar: a numeric vector of 12 parameters corresponding to the PhenoFlex model.\r\nIt is important to maintain the correct order of parameters‚Äîif they are misaligned, function may produce incorrect results or fail altogether.\r\nThe function performs three main tasks:\r\nInput checks: It ensures that temperature parameters are valid (e.g.¬†base temperature \\(T_b\\) is lower than the optimal temperature \\(T_u\\), and \\(T_u\\) is less than the critical temperature \\(T_c\\)).\r\nModel execution: It runs the PhenoFlex model and retrieves the bloomindex (the row number where accumulated heat exceeds the requirement \\(z_c\\)).\r\n3.Bloom date computation: Converts the bloomindex into a Julian Day, factoring the hour of blooming to provide a more precise results. If the requirement is met at noon, the Julian Day is returned unchanged; otherwise, a fractional adjustment is applied.\r\nCustomizing Wrapper Function\r\nThe requirements for a modelfn wrapper a fairly loose ‚Äîthere‚Äôs no strict enforcement of how many parameters it must accept or in what order.\r\nThis flexibility allows us to exclude certain parameter from calibration, which can be useful when a parameter has limited influence on model performance or is already well understood. All we need to do is manually fix its value inside the wrapper function, and ensure it‚Äôs excluded from par.guess, lower and upper when calling chillR::phenologyFitter().\r\nHere‚Äôs an example where we fix \\(T_c\\) (critical temperature) at 36¬∞C. Since it is no longer estimated, par will contain only 11 parameters:\r\n\r\n\r\nPhenoFlex_GDHwrapper_fixed <- function (x, par, Tc = 36) \r\n{\r\n  par <- c(par[1:9], Tc, par[10:11])\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, \r\n                            times = seq_along(x$Temp), \r\n                            yc = par[1], zc = par[2], \r\n                            s1 = par[3], Tu = par[4], \r\n                            E0 = par[5], E1 = par[6], \r\n                            A0 = par[7], A1 = par[8], \r\n                            Tf = par[9], Tc = par[10], \r\n                            Tb = par[11], slope = par[12], \r\n                            Imodel = 0L, \r\n                            basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + \r\n             which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nUsing the Custom Wrapper\r\nOnce your wrapper is defined, you can pass it to chillR::phenologyFitter() via modelfn argument. Be sure to:\r\nExclude the fixed parameter \\(T_c\\) from par.guess, lower and upper\r\nAdjust the parameter indices in the wrapper function\r\nUse the modified wrapper in the fitter function call\r\nHere is an adapted example from the chillR::phenologyFitter() help page:\r\n\r\n\r\ndata(KA_weather)\r\ndata(KA_bloom)\r\nhourtemps <- stack_hourly_temps(KA_weather, \r\n                                latitude=50.4)\r\nSeasonList <- genSeasonList(hourtemps$hourtemps, \r\n                            years=c(2007,2008))\r\n#remove Tc from par.guess, upper and lower\r\n#--> only 11 parameters to estimate\r\n#order: yc, zc, s1, Tu, E0, E1, A0, A1, Tf, Tb, slope   \r\npar <- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, \r\n         5.939917e13, 4, 4, 1.6)\r\nupper <- c(41, 200, 1, 30, 4000, 10000, \r\n           7000, 6.e13, 10, 10, 50)\r\nlower <- c(38, 180, 0.1, 0, 3000, 9000, \r\n           6000, 5.e13, 0, 0, 0.05)\r\nX <- phenologyFitter(par.guess=par, \r\n                     bloomJDays=KA_bloom$pheno[c(24,25)], \r\n  SeasonList=SeasonList, lower=lower, upper=upper,\r\n  control=list(smooth=FALSE, verbose=TRUE, maxit=10, \r\n               nb.stop.improvement=5))\r\nsummary(X)\r\nplot(X)\r\n\r\n\r\nBonus: Override the Default Value via ...\r\nThe best part about adding \\(T_c\\) as an optional argument to your wrapper is that you can override its value directly when calling chillR::phenologyFitter()‚Äîwithout rewriting the wrapper.\r\n\r\n\r\ndata(KA_weather)\r\ndata(KA_bloom)\r\nhourtemps <- stack_hourly_temps(KA_weather, \r\n                                latitude=50.4)\r\nSeasonList <- genSeasonList(hourtemps$hourtemps, \r\n                            years=c(2007,2008))\r\n#remove Tc from par.guess, upper and lower\r\n#--> only 11 parameters to estimate\r\n#order: yc, zc, s1, Tu, E0, E1, A0, A1, Tf, Tb, slope  \r\npar <- c(40, 190, 0.5, 25, 3372.8, 9900.3, \r\n         6319.5, 5.939917e13, 4, 4, 1.6)\r\nupper <- c(41, 200, 1, 30, 4000, 10000, \r\n           7000, 6.e13, 10, 10, 50)\r\nlower <- c(38, 180, 0.1, 0, 3000, 9000,\r\n           6000, 5.e13, 0, 0, 0.05)\r\nX <- phenologyFitter(par.guess=par, \r\n                     bloomJDays=KA_bloom$pheno[c(24,25)], \r\n  SeasonList=SeasonList, lower=lower, upper=upper,\r\n  Tc = 30,\r\n  control=list(smooth=FALSE, verbose=TRUE, maxit=10, \r\n               nb.stop.improvement=5))\r\nsummary(X)\r\nplot(X)\r\n\r\n\r\nThis way, if you later want to fix \\(T_c\\) at a different value, you don‚Äôt need to edit the wrapper‚Äîjust pass a new value via $T_c=...$ in the function call. Much cleaner!\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-28T17:42:45+01:00"
    },
    {
      "path": "implement-meigo.html",
      "title": "Implementing Alternative Calibration Algortihms",
      "author": [],
      "contents": "\r\nMotivation\r\nThe chapters on fixing model parameters and introducing intermediate parameters showed that customizing the evaluation function is relatively simple. It gets a bit more complicated when you want to try out a different optimization algorithm than the simulated annealing function, implemented in the phenologyFitter() function. For example, I wanted to use the optimization framework MEIGO (Egea et al., 2014). MEIGO is also available on bioconductor, a platform where you can access R packages similar to CRAN. The installation via bioconductor is in my opinion less convenient than via CRAN and installing MEIGOR package was error-prone. As a quick fix, I mirrored the core of the MEIGOR package in my custom R package LarsChill (quite an original name, I know) https://github.com/larscaspersen/addition_chillR. Here you can find the original vignette for MEIGOR: https://www.bioconductor.org/packages/release/bioc/manuals/MEIGOR/man/MEIGOR.pdf. I only took the function for the Enhanced Scatter Search (ESS), which you can find via LarsChill::custom_essr(), but the functionality is just the same as in the original MEIGOR package.\r\nThe ESS has some advantages and disadvantages compared to the simulated annealing algorithm. It was developed for complex optimization problems, it allows to screen for many different sets of model parameters, something I had the feeling the standard phenologyFitter() function was lacking. It is also relatively fast for small datasets (with <100 observations). You can specify additional inequality constraints when setting up the optimization problem. As you saw in the previous example, also the GDH_wrapper has some additional constraints implemented, but MEIGOR makes these easier to detect and to adjust and it also allows to specify acceptable ranges. I also like, that the function returns all the intermediate solutions that were surpassed by other sets of parameters in the course of the optimization run, it also returns the intermediate error scores, convenient if you want to make sure that the algorithm has converged or not. A big disadvantage is, that the speed of the ESS algorithm deteriorates quite fast for larger datasets, so if you have lots of observations in the calibration dataset it is better to stick with the simulated annealing algorithm used in the phenologyFitter function.\r\nImplementing a new optimization algortihm for PhenoFlex is quite messy\r\nTo optimize PhenoFlex with another algorithm involves a little bit more work. The ESS optimization algorithm needs a function that calculates the model error for a particular set of parameters and temperature data. In most optimization problems model error is measured as Residual Sum of Squares (RSS), which is in our case simply the sum of the squared differences between predicted and observed bloom dates. The PhenoFlex_GDH_wrapper() function, however, only returns the bloom date for one season of temperatures and it does not even compare the prediction to the observed bloom dates. The function taking care of calculating the RSS is a hidden function called chillR:::chifull(). Note that I used three colons, when referring to the function, because this notation allows to access ‚Äúhidden‚Äù functions, that did not get exported when creating the chillR package.\r\nI decided to maintain the modular structure of the phenologyFitter() function, where you specify the function how to calculate a bloom date with the modelfn argument, like with the PhenoFlex_GDH_wrapper() function. The evaluation function needs to do three things:\r\ncalculate bloom dates based on the temperature data specifeid in SeasonList\r\ncalculate RSS by comparing the predicted bloom dates with the observed ones, specified in bloomJDays\r\ncheck model parameters for additional constraints\r\nHere is an example of an evaluation function, that is compatible with the ESS algorithm of MEIGOR. I tried to\r\nbundle all the different cusotm evaluaiton functions and wrapper functions in a seperate package called\r\nevalpheno, you can find the package here: https://github.com/larscaspersen/eval_phenoflex\r\n\r\n\r\nevalpheno::evaluation_function_meigo\r\n\r\nfunction (x, modelfn, bloomJDays, SeasonList, na_penalty = 365) \r\n{\r\n    par <- x\r\n    pred_bloom <- unlist(lapply(X = SeasonList, FUN = modelfn, \r\n        par = par))\r\n    pred_bloom <- ifelse(is.na(pred_bloom), yes = na_penalty, \r\n        no = pred_bloom)\r\n    F <- sum((pred_bloom - bloomJDays)^2)\r\n    g <- rep(0, 5)\r\n    g[1] <- x[4] - x[11]\r\n    g[2] <- x[10] - x[11]\r\n    g[3] <- x[10] - x[4]\r\n    g[4] <- exp((10 * x[5])/(297 * 279))\r\n    g[5] <- exp((10 * x[6])/(297 * 279))\r\n    return(list(F = F, g = g))\r\n}\r\n<bytecode: 0x000001338437b2b0>\r\n<environment: namespace:evalpheno>\r\n\r\nAs you can see, the evaluation functions is actually quite simple. At first we predict bloom dates, using the entries of SeasonList, t the function to calculate bloom dates specified in modelfn and the parameters specified in x(in the vignette for the MEIGOR package they always called the vector of the parameter x, while in PhenoFlex it is the name for the temperature data. Because I was not sure if the naming affected something, I followed the naming convention of the vignette, though it might be confusing.).\r\nIn case there is an NA in the predicted bloom dates, the value gets replaced with a value specified in na_penalty. Next, predicted and observed bloom dates get compared and the RSS is calculated and saved in the object F. The last and longest part is about the inequality constraints. The first three of the constrains should be familiar, as they are the same as in the PhemoFlex_GDH_wapper() function. Constrains 4 and 5 are new, relate to the \\(Q_{10}\\) metric, that expresses by which factor a biological process speeds up for an increase in temperature by 10¬∞C (Hegarty, 1973). In biological systems \\(Q_{10}\\) values of 1.5 to 3.5 are deemed realisitic (Egea et al., 2021). In the early PhenoFlex papers (Fernandez et al., 2022; Luedeling et al., 2021) the \\(Q_{10}\\) metric was checked after the calibration, but I think it makes even more sense to check the metric during the calibration. The results of the inequality constraints get saved in the vector g. Both, the error function F and the results of the inequality constrains g get returned to the optimization function.\r\nBefore running the optimization function, we can specify acceptable upper and lower ranges for the inequality constrains, similar to how you do it for the search space of the model parameters.\r\nWorkflow using ESS algorithm\r\nHere is an example of the specifications I made when calibrating PhenoFlex for a large dataset of temperate fruit trees (Caspersen et al., 2025):\r\n\r\n\r\n#search space of model parameters\r\n#        yc      zc     s1      Tu      theta_c   tau      piec    Tf     Tb     slope\r\nx_0 <- c(24.79,  337.04,  0.2529,  17.72,  285.54,     45.67,    29.49,  2.97,  1.87,  2.69)\r\nx_U <- c(80,    500,    1.0,    30,     287,       48,      50,    10,    10,     5.00)\r\nx_L <- c(20,    100,    0.1,    15,     284,       16,      24,     2,     2,     1.2)\r\n\r\n#limits for the inequality constraints\r\n#         #gdh parameters   #q10 for E0 and E1\r\nc_L <- c(  0,   0,   0,     1.5, 1.5)\r\nc_U <- c(Inf, Inf, Inf,     3.5, 3.5)\r\n\r\nproblem<-list(f=\"evalpheno::eval_phenoflex_single_twofixed\",\r\n              x_0 = x_0,\r\n              x_L = x_L,\r\n              x_U = x_U,\r\n              c_L = c_L, \r\n              c_U = c_U)\r\n\r\n\r\n#options for fitter\r\nopts<-list(#maxeval = 1000,\r\n  maxtime = 60 * 10, \r\n  local_solver = 'DHC', \r\n  local_bestx = 1)\r\n\r\nLarsChill::custom_essr(problem = problem,\r\n                       opts = options,\r\n                       modelfn = custom_PhenoFlex_GDHwrapper,\r\n                       bloomJDays = pheno,\r\n                       SeasonList = season_cal_list)\r\n\r\n\r\nThe first part is about the search space of the model parameters. I decided to optimize based on the intermediate model parameters and to fix two of the model parameters (\\(\\theta^{*} = 279\\), \\(T_c=36\\)). x_0 is the initial guess, x_L the lower search range and x_U the upper range. The upper acceptable limit of the inequality constrain is specified in c_U and the lower limit in c_L. In the first three constrains for the heat submodel temperature parameters, we excluded any negative value, in the last two relating to the \\(Q_{10}\\) metric, we excluded values outside the range of 1.5 to 3.5. All of that information is bundled in a list called problem. There it is also specified which evaluation function we are using, here I use the function evalpheno::eval_phenoflex_single_twofixed. Make sure that you omit the paranthesis after function name, because you want to only specify the name and not exexcute the function. The problem-list gets followed by the option list, here you specify settings of the optimization algorithm. maxtime specifies the time-limit for how long the algortihm should optimize (in seconds). local_solver specifies which optimization algorithm should be run when ESS found a set of model parameter leading to a lower RSS. The local solver makes a more refined narrower search around the newly found, better model parameters. local_bestx specifies how often the local search is called. When set to 1, local search is only triggered immediately after a better set is found, higher values would postpone the local search for some further iterations, that can be beneficial when the global search quickly finds even better parameter sets. You can also specifiy how many iterations the algorithms should make with maxeval. For more options, check the MEIGOR vignette.\r\nLastly, the problem and option list get supplied to the LarsChill::custom_essr() function. This function does the optimization and should hopefully return good model parameters for your dataset. As you may have noticed, I also supplied three further arguments to the function: modelfn, bloomJDays and SeasonList. These are inputs for the evaluation function specified in the problem list. They are the same when running the phenologyFitter() function.\r\nThe ouput\r\nThe out of the LarsChill::custom_essr() looks a bit different than the output of the chillR::phenologyFitter() function. The output is a list with several elements. Most importantly, you can find the optimized model parameters under the name xbest. Other interesting outputs include the intermediate set of model parameters that were at the time the best before an even better set was found by the algorithm. You can also check f and fbest for the development of the residual sum of squares (RSS) and the final RSS result.\r\n\r\n\r\n\r\nCaspersen, L., Schiffers, K., Picornell, A., Egea, J.A., Delgado, A., El Yaacoubi, A., Benmoussa, H., Rodrigo, J., Fad√≥n, E., Ben Mimoun, M., Ghrab, M., Kodad, O., Ruiz, D., Luedeling, E., 2025. Contrasting Responses to Climate Change ‚Äì Predicting Bloom of Major Temperate Fruit Tree Species in the Mediterranean Region and Central Europe. https://doi.org/10.2139/ssrn.5106075\r\n\r\n\r\nEgea, J.A., Egea, J., Ruiz, D., 2021. Reducing the uncertainty on chilling requirements for endodormancy breaking of temperate fruits by data-based parameter estimation of the dynamic model: A test case in apricot. Tree Physiology 41, 644‚Äì656. https://doi.org/10.1093/treephys/tpaa054\r\n\r\n\r\nEgea, J.A., Henriques, D., Cokelaer, T., Villaverde, A.F., MacNamara, A., Danciu, D.-P., Banga, J.R., Saez-Rodriguez, J., 2014. MEIGO: An open-source software suite based on metaheuristics for global optimization in systems biology and bioinformatics. BMC Bioinformatics 15, 136. https://doi.org/10.1186/1471-2105-15-136\r\n\r\n\r\nFernandez, E., Schiffers, K., Urbach, C., Luedeling, E., 2022. Unusually warm winter seasons may compromise the performance of current phenology models ‚Äì Predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology 322, 109020. https://doi.org/10.1016/j.agrformet.2022.109020\r\n\r\n\r\nHegarty, T.W., 1973. Temperature Coefficient (Q10), Seed Germination and Other Biological Processes. Nature 243, 305‚Äì306. https://doi.org/10.1038/243305a0\r\n\r\n\r\nLuedeling, E., Schiffers, K., Fohrmann, T., Urbach, C., 2021. PhenoFlex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-28T19:24:19+01:00"
    },
    {
      "path": "index.html",
      "title": "Customizing PhenoFlex",
      "description": "This website collects all the different methods to tweak PhenoFlex to your needs.\n",
      "author": [
        {
          "name": "Lars Caspersen",
          "url": "https://example.com/norajones"
        }
      ],
      "date": "`r Sys.Date()`",
      "contents": "\r\n\r\n          \r\n          \r\n          Custom PhenoFlex\r\n          \r\n          \r\n          Home\r\n          \r\n          \r\n          Customized Model Calibration\r\n           \r\n          ‚ñæ\r\n          \r\n          \r\n          Overview\r\n          Fixing Model Parameters\r\n          Intermediate Model Parameters\r\n          Implement another optimization algorithm\r\n          \r\n          \r\n          Phenology Projections\r\n          Plotting\r\n          ‚ò∞\r\n          \r\n          \r\n      \r\n        \r\n          \r\n            \r\n              \r\n            \r\n              Customizing PhenoFlex\r\n            \r\n            \r\n              \r\n                \r\n                    \r\n                      \r\n                        HortiBonn\r\n                      \r\n                    \r\n                  \r\n                                    \r\n                    \r\n                      \r\n                         GitHub\r\n                      \r\n                    \r\n                  \r\n                                    \r\n                    \r\n                      \r\n                         Email\r\n                      \r\n                    \r\n                  \r\n                                  \r\n            \r\n          \r\n        \r\n        \r\n        \r\n          \r\n            \r\n            Hi and welcome, fellow phenology modellers and aspiring\r\n            ones!\r\n            This website compiles various ways to customize\r\n            PhenoFlex to better suit your needs. I am\r\n            Lars\r\n            Caspersen, a a PhD student in the HortiBonn\r\n            group at the University of Bonn, Germany, where my\r\n            research focuses on phenology modeling.\r\n            During my PhD, I primarily worked with\r\n            PhenoFlex (Luedeling\r\n            et al., 2021), available through the\r\n            chillR package (Luedeling et al., 2023). Along the\r\n            way, I was asked to document my experiences, share what I\r\n            learned, and what tools I created - so this website was\r\n            born!\r\n            To support collaboration and make my workflow more\r\n            accessible, I bundled my custom functions into two R\r\n            packages:\r\n            LarsChill\r\n            - a collection of general-purpose functions that complement\r\n            chillR (Yes, naming things is not my\r\n            strongest skill üòÖ)\r\n            evalpheno\r\n            - focused on functions to calculate bloom dates, especially\r\n            helpful during PhenoFlex calibration.\r\n            These packages are currently available via GitHub only\r\n            (not CRAN). Over time, some of their features may be\r\n            integrated into our main package, chillR.\r\n            This site serves as a hub for all the tweaks,\r\n            adaptations, and custom versions of\r\n            PhenoFlex I developed through my PhD. I\r\n            hope it proves useful for others working in this field ‚Äî\r\n            whether you‚Äôre new to PhenoFlex or looking to explore it\r\n            more deeply.\r\n            If you run into any issues, have questions, or just want\r\n            to connect, don‚Äôt hesitate to reach out! You can open an\r\n            issue on GitHub\r\n            or email me (or my supervisor Eike Luedeling). Details are\r\n            on the left-hand side of the page.\r\n            ‚ö†Ô∏è Note: This collection of vignettes is\r\n            not a general introduction to PhenoFlex. For that,\r\n            please check out:\r\n            The official\r\n            PhenoFlex vignette\r\n            The course book: Tree\r\n            phenology analysis with R\r\n            And, of course, the PhenoFlex\r\n            publication.\r\n            \r\n            üôè Acknowledgements\r\n            I learned a lot about building websites like this from\r\n            Jaqueline Wingen‚Äôs learning logbook, created during the\r\n            Tree Phenology Analysis with R course. Check out\r\n            her amazing site: https://jacqwng.github.io/Tree-phenology-analysis-with-R/index.html\r\n            \r\n            References\r\n            \r\n            \r\n            Luedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical\r\n            Methods for Phenology\r\n            Analysis in Temperate\r\n            Fruit Trees.\r\n            \r\n            \r\n            Luedeling, E., Schiffers, K., Fohrmann, T., Urbach, C.,\r\n            2021. PhenoFlex - an integrated model to\r\n            predict spring phenology in temperate fruit trees.\r\n            Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n            \r\n            \r\n            \r\n            \r\n            \r\n          \r\n        \r\n      \r\n    \r\n\r\n    \r\n      \r\n        \r\n          \r\n            \r\n              \r\n            \r\n              Customizing PhenoFlex\r\n            \r\n            \r\n              \r\n                \r\n                                    \r\n                    \r\n                      HortiBonn\r\n                    \r\n                  \r\n                                    \r\n                    \r\n                       GitHub\r\n                    \r\n                  \r\n                                    \r\n                    \r\n                       Email\r\n                    \r\n                  \r\n                                  \r\n              \r\n            \r\n            \r\n              \r\n              Hi and welcome, fellow phenology modellers and\r\n              aspiring ones!\r\n              This website compiles various ways to customize\r\n              PhenoFlex to better suit your needs. I am\r\n              Lars\r\n              Caspersen, a a PhD student in the HortiBonn\r\n              group at the University of Bonn, Germany, where my\r\n              research focuses on phenology modeling.\r\n              During my PhD, I primarily worked with\r\n              PhenoFlex (Luedeling et al., 2021),\r\n              available through the chillR package\r\n              (Luedeling et al., 2023).\r\n              Along the way, I was asked to document my experiences,\r\n              share what I learned, and what tools I created - so this\r\n              website was born!\r\n              To support collaboration and make my workflow more\r\n              accessible, I bundled my custom functions into two R\r\n              packages:\r\n              LarsChill\r\n              - a collection of general-purpose functions that\r\n              complement chillR (Yes, naming things is\r\n              not my strongest skill üòÖ)\r\n              evalpheno\r\n              - focused on functions to calculate bloom dates,\r\n              especially helpful during PhenoFlex calibration.\r\n              These packages are currently available via GitHub only\r\n              (not CRAN). Over time, some of their features may be\r\n              integrated into our main package, chillR.\r\n              This site serves as a hub for all the tweaks,\r\n              adaptations, and custom versions of\r\n              PhenoFlex I developed through my PhD. I\r\n              hope it proves useful for others working in this field ‚Äî\r\n              whether you‚Äôre new to PhenoFlex or looking to explore it\r\n              more deeply.\r\n              If you run into any issues, have questions, or just\r\n              want to connect, don‚Äôt hesitate to reach out! You can open\r\n              an issue on GitHub\r\n              or email me (or my supervisor Eike Luedeling). Details are\r\n              on the left-hand side of the page.\r\n              ‚ö†Ô∏è Note: This collection of vignettes\r\n              is not a general introduction to PhenoFlex. For\r\n              that, please check out:\r\n              The official\r\n              PhenoFlex vignette\r\n              The course book: Tree\r\n              phenology analysis with R\r\n              And, of course, the PhenoFlex\r\n              publication.\r\n              \r\n              üôè Acknowledgements\r\n              I learned a lot about building websites like this from\r\n              Jaqueline Wingen‚Äôs learning logbook, created during the\r\n              Tree Phenology Analysis with R course. Check out\r\n              her amazing site: https://jacqwng.github.io/Tree-phenology-analysis-with-R/index.html\r\n              \r\n              References\r\n              \r\n              \r\n              Luedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical\r\n              Methods for Phenology\r\n              Analysis in Temperate\r\n              Fruit Trees.\r\n              \r\n              \r\n              Luedeling, E., Schiffers, K., Fohrmann, T., Urbach, C.,\r\n              2021. PhenoFlex - an integrated model to\r\n              predict spring phenology in temperate fruit trees.\r\n              Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n              \r\n              \r\n              \r\n              \r\n              \r\n            \r\n        \r\n      \r\n    \r\n\r\n    \r\n    \r\n    ",
      "last_modified": "2025-03-28T18:12:04+01:00"
    },
    {
      "path": "intermediate-model-parameters.html",
      "title": "Intermediate Model Parameters",
      "author": [],
      "contents": "\r\nMotivation\r\nPhenoFlex is a phenology model developed by Luedeling et al. (2021), accessible via the chillR package (Luedeling et al., 2023). During my PhD, I primarily worked with PhenoFlex, developing customized functions to improve its usability. These functions helped streamline tasks such as integrating various calibration methods, algorithms, and fitting multiple phenological stages simultaneously.\r\nThe standard PhenoFlex routines, including model runs, calibration, cross-validation, and plotting outputs for the chill and heat accumulation submodels, are well-documented by Urbach et al. (2021). For further details, see the the PhenoFlex vignette. These routines formed the foundation for early phenology studies using PhenoFlex (Fernandez et al., 2022; Luedeling et al., 2021).\r\nIn these studies, many iterations of model calibration were carried out. That means you run the calibration fitting function chillR::PhenologyFitter(), wait and check if the estimated model parameters provide better predictions, if yes, then you start another round of calibration, using the estimated parameters as a new starting point. If they did not improve the predictions, you may want to change the search space, either make them wider or narrower to help the optimization algorithm to find new sets of parameters. 15 to 30 rounds of iterations were used to find the final set of parameters. This workflow resulted in fairly good parameters, the validation RMSE was below 4 days in these studies, however, it is a lot of work and takes quite a while. And most importantly, it is difficult to scale up the process, because it involves a lot of manual checking, adjusting search ranges, checking temperature response plots.\r\nOne of my first tasks as a PhD was to apply PhenoFlex to an extensive phenology dataset assembled in the Adapting Mediterranean Orchards (AdaMedOr) project (Luedeling et al., 2024). The dataset comprised 270 cultivars of seven temperate fruit tree species (almond, pistachio, apple, pear, plum, sweet cherry, apricot). More than 100 cultivars had 20 or more observations (Caspersen et al., 2025), which is deemed to be the critical number of observations for model calibration (Urbach et al., 2021). For most of the cultivars we had 20 observations, so after a 75% calibration - 25% validation split only 5 observations are in the validation data set. Validating the model only on 5 observations seems quite a stretch, so we wanted to cross-validate the calibrated the model, so we had to even do more calibration steps.\r\nTheoretical Background\r\nTogether with Jose Egea, member of the AdaMedOr project consortium and experienced in global optimization problems, we hypothesized that part of the calibration problem are the ranges of the model parameters. In particular the parameters controlling the chill submodel. The Dynamic Model (Fishman et al., 1987a, 1987b) consists of two ordinary differential equation (ODE) modeling the build-up and degradation of some (hypothetical) precursor of a dormancy breaking factor (PDBF). After a critical amount of PDBF is accumulated, a certain share gets converted to a non-degradable dormancy breaking factor (DBF). For the ODEs controlling build-up and degradation of PDBF four parameters are needed: \\(E_0\\): activation energy for forming PDBF, \\(A_0\\): amplitude of the formation process, \\(E_1\\): activation energy for degrading PDBF and \\(A_1\\): amplitude of the degradation process. All of these parameters are not really tangible for most people, so setting boundaries is difficult. It is even more difficult, because the default value of \\(A_1\\) for example is on a ridiculous scale, 5.939917e13, that is a number wit 13 zeros before the digit! Good luck finding an appropriate search space that does not limit the algorithm too much but still is manageable. By the way, the default search space in Urbach et al. (2021) might be too narrow, as in the original paper describing the Dynamic Model parameter they ranged from 0.1797e15 to 0.1875e17, while there the search space is ‚Äúonly‚Äù between 5.e13 to 6.e13. Also, they had initially ridiculous ranges in the other estimated model parameters, for instance \\(A_0\\) ranged from 0.1386e4 to 0.1405e15. So in summary, finding appropriate ranges for these parameters is a difficult task, and even if you find them, it is a difficult search space for the optimization algorithm to navigate. Based on my limited experience, the optimizer is often ‚Äústuck‚Äù for these parameters and does not offer different sets of parameters for \\(E_0\\), \\(E_1\\), \\(A_0\\) and \\(A_1\\).\r\nEgea et al. (2021) point out, that the \\(E_0\\) to \\(A_1\\) parameters of the Dynamic Model get actually calculated based on a set of more tangible parameters, describing the experimental set-up, that serves as a basis of the Dynamic Model. These intermediate parameters are according to Fishman et al. (1987b): \\(\\theta^{*}\\): the temperature, leading to a maximal chilling effect, \\(\\theta_c\\) the highest temperature which still gives a positive response, \\(\\tau\\): the time needed to accumulate one critical portion of DBF under optimal temperature conditions and \\(\\pi_c\\) and the length of the cycle in a two-temperature regime, which leads to complete chilling negation.\r\nOther parameters describing the experiment, include the alternated temperatures of the experiment (\\(\\theta_1=297K\\), \\(\\theta_2=279K\\)), and the fixed relation of these two temperatures (\\(\\eta = \\frac{1}{3}\\)). The \\(E_0\\) to \\(A_1\\) parameters get estimated on \\(\\theta^{*}\\), \\(\\theta_c\\), \\(\\tau\\) and \\(\\pi_c\\) So Egea et al. (2021) proposed run a global optimization procedure on the intermediate parameters instead, because they are measured in Kelvin and hours, and boundaries of the search space are easier to set. Unfortunately, this involved to dig through some nasty looking equations, check out Egea et al. (2021) and the original publication of the Dynamic Model, equations 33 to 38 (Fishman et al., 1987b). In the end, a clean conversion is not possible for \\(A_1\\) and \\(A_0\\), they need to be estimated using an optimization problem.\r\nHere is the set of equations that need to be solved (taken from Egea et al. (2021)):\r\n\\[\r\n\\begin{align*}\r\nE_1=\\frac{E_0-E_1}{e^{(E_1-E_0)*q}-1}*\\frac{1}{ln(1-e^{(E_0-E1)*q})}\\\\\r\nA_1=-e^{\\frac{E_1}{\\theta^{*}}}*\\frac{ln(1-e^{(E_0-E_1)*q})}{\\tau}\\\\\r\nA_0=A_1e^{(\\frac{E_0-E_1}{\\theta_c})}\\\\\r\n\\frac{e^{(\\frac{E_1-E_0}{\\theta_c})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}{e^{(\\frac{E_1-E_0}{\\theta_2})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}=\\frac{1-e^{-(k_1(\\theta_2)*(1-\\eta)*\\pi_c)}}{1-e^{-([k_1(\\theta_1)*\\eta+k_1(\\theta_2)*(1-\\eta)]*\\pi_c)}}\\\\\r\n\\text{with } q=\\frac{1}{\\theta^{*}}+\\frac{1}{\\theta_c}\\text{; }\\theta_1=297K\\text{; }\\theta_2=279K\\text{; }\\eta=\\frac{1}{3}\r\n\\end{align*}\r\n\\]\r\nConverting Parameters\r\nTo convert the intermediate model parameters, you can use the function LarsChill::convert_parameters(). It is written to take all 12 PhenoFlex model parameters, because at the time that was the easiest way for me to implement it. But it only affects the four intermediate model parameters\r\nHere is an example\r\n\r\n\r\n#       yc   zc   s1   Tu  theta_star theta_c tau  pie_cTf Tu Tb slope\r\npar <- c(40, 190, 0.5, 25,  281,      287,     30, 24,  4, 36,  4,  1.60)\r\nLarsChill::convert_parameters(par)\r\n\r\n [1] 4.000000e+01 1.900000e+02 5.000000e-01 2.500000e+01 4.457844e+03\r\n [6] 1.016131e+04 4.197532e+05 1.793094e+14 4.000000e+00 3.600000e+01\r\n[11] 4.000000e+00 1.600000e+00\r\n\r\nLuckily, this is also what Fishman et al. (1987b) calculated for these sets of intermediate parameters, so it seems that the function is working alright (if you want to compare, check first row of Table 1, Fishman et al. (1987b)).\r\nBecause A0 and A1 get estimated using an optimization problem, it could theoretically happen that the optimization algorithm fails or that no solution is available. This can be problematic inside an optimization algorithm, so I included options how to handle such a failure to converge. Check details of the failure_return argument.\r\nAdjusting the Wrapper Function for intermediate parameters\r\nYou need to adjust the evaluation functions if you want to use the intermediate model parameters in your optimization problem. Conveniently, PhenoFlex was coded in a modular way, so that evaluation functions can be modified. Inconveniently, PhenoFlex has a quite nested code structure, so that it is at first a bit challenging to find out what exactly needs to be adjusted. The argument modelfn of the phenologyFitter() function controls the function, that calculates bloom dates based on the supplied temperature data and parameters. If we want to exchange the \\(E_0\\) to \\(A_1\\) parameters with the intermediate ones, adjusting the input of the modelfn argument is the way to go.\r\n\r\n\r\nchillR::PhenoFlex_GDHwrapper\r\n\r\nfunction (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n<bytecode: 0x0000018d2eb2c9e8>\r\n<environment: namespace:chillR>\r\n\r\nAs you can see, the PhenoFlex_GDHwrapper wrapper is a relatively simple funciton. It takes x and par as inputs. x should be of the same format as tge output of the chillR::genSeasonList() function, it produces a list of data.frames, each data.frame has three columns: ‚ÄòTemp‚Äô, ‚ÄòJDay‚Äô and ‚ÄòYear‚Äô. par is a numeric vector with twelve entries, containing the PhenoFlex model parameters. Pay attention, that the order of parameters is correct, otherwise the function may not work or produce funny results. The first par of the code ensures that temperatures of the heat submodel make sense, the base temperature \\(T_b\\) must be lower than optimal temperature \\(T_u\\) and secondly, \\(T_u\\) should not be larger than the critical temperature \\(T_c\\). The next part of the code inserts the model parameters and the temperature data into PhenoFlex. PhenoFlex returns the bloomindex, this is not the bloom date but indicates at which row of the temperature data.frame x the accumulated heat exceeds the heat requirement \\(z_c\\). The last part of the code calculates the bloom date, it has a routine what to do when the accumulated heat never exceeds \\(z_c\\) (it returns an NA to the phenologyFitter() function) or it calculates the Julian Day (with digits). The bloom date calculation looks at first glance a bit complicated, but it accounts for the hour when the requirement is met. When it is met at noon at 12:00, it returns the Julian Day without alteration. If it is earlier, it subtracts a fraction and if it is later than noon it adds a fraction.\r\nHere is an example with intermediate model parameters:\r\n\r\n\r\nPhenoFlex_GDHwrapper_adjusted <- function (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n  \r\n  #convert bloom dates\r\n  par_converted <- LarsChill::convert_parameters(par)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par_converted[1], zc = par_converted[2], s1 = par_converted[3], Tu = par_converted[4], E0 = par_converted[5], \r\n        E1 = par_converted[6], A0 = par_converted[7], A1 = par_converted[8], Tf = par_converted[9], Tc = par_converted[10], \r\n        Tb = par_converted[11], slope = par_converted[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nDownside of this approach is, that the conversion happens for each bloom date calculation seperately. But it would be necissary to convert it once and then calculate bloom dates for all the SeasonList entries. Unfortunately, the modelfn argument is the only way to customize the functions without having to build a whole custom version of phenologyFitter() function. I address this shortcoming in the chapter on customized model calibration.\r\n\r\n\r\n\r\nCaspersen, L., Schiffers, K., Picornell, A., Egea, J.A., Delgado, A., El Yaacoubi, A., Benmoussa, H., Rodrigo, J., Fad√≥n, E., Ben Mimoun, M., Ghrab, M., Kodad, O., Ruiz, D., Luedeling, E., 2025. Contrasting Responses to Climate Change ‚Äì Predicting Bloom of Major Temperate Fruit Tree Species in the Mediterranean Region and Central Europe. https://doi.org/10.2139/ssrn.5106075\r\n\r\n\r\nEgea, J.A., Egea, J., Ruiz, D., 2021. Reducing the uncertainty on chilling requirements for endodormancy breaking of temperate fruits by data-based parameter estimation of the dynamic model: A test case in apricot. Tree Physiology 41, 644‚Äì656. https://doi.org/10.1093/treephys/tpaa054\r\n\r\n\r\nFernandez, E., Schiffers, K., Urbach, C., Luedeling, E., 2022. Unusually warm winter seasons may compromise the performance of current phenology models ‚Äì Predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology 322, 109020. https://doi.org/10.1016/j.agrformet.2022.109020\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987a. The temperature-dependence of dormancy breaking in plants - computer-simulation of processes studied under controlled temperatures. Journal of Theoretical Biology 126, 309‚Äì321. https://doi.org/10.1016/s0022-5193(87)80237-0\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987b. The temperature dependence of dormancy breaking in plants: Mathematical analysis of a two-step model involving a cooperative transition. Journal of Theoretical Biology 124, 473‚Äì483. https://doi.org/10.1016/S0022-5193(87)80221-7\r\n\r\n\r\nLuedeling, E., Caspersen, L., Delgado, A., Egea, J.A., Ruiz, D., Ben Mimoun, M., Benmoussa, H., Ghrab, M., Kodad, O., El Yaacoubi, A., Fad√≥n, E., Rodrigo, J., 2024. Long-term phenology observations for temperate fruit trees in the Mediterranean region (and Germany).\r\n\r\n\r\nLuedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical Methods for Phenology Analysis in Temperate Fruit Trees.\r\n\r\n\r\nLuedeling, E., Schiffers, K., Fohrmann, T., Urbach, C., 2021. PhenoFlex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n\r\n\r\nUrbach, C., Luedeling, E., Schiffers, K., 2021. PhenoFlex - vignette within the chillR package.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-28T18:44:17+01:00"
    },
    {
      "path": "overview_custom-model-calibration.html",
      "title": "Overview: Custom Model Calibration",
      "author": [],
      "contents": "\r\nThis section focuses on calibrating PhenoFlex. The function chillR::phenologyFitter() is a great starting point for estimating model parameters. However, it may not always be the perfect fit for your specific use case. For example, you might want to:\r\nKeep certain model parameters fixed\r\nUse a different global optimization algorithm\r\nReplace parameters with intermediate, more narrowly defined ones\r\nIntroduce additional parameters to the model\r\nShare (or pool) parameters across cultivars of the same species\r\nOr even model a sequence of phenological events within a single framework\r\nThis page brings together a variety of customizations you might consider when calibrating PhenoFlex\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-28T18:12:19+01:00"
    },
    {
      "path": "overview_phenology_projections.html",
      "title": "Overview: Phenology Projections",
      "author": [],
      "contents": "\r\nOnce you have calibrated the model, the real fun begins. Here I want to share content on how to evaluate the model parameters, run projections etc.\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-28T18:11:01+01:00"
    },
    {
      "path": "overview_plotting.html",
      "title": "Overview: Plotting",
      "author": [],
      "contents": "\r\nHere I will share some functions I created to vizualize output of PhenoFlex\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-28T18:12:32+01:00"
    },
    {
      "path": "start.html",
      "title": "Working with PhenoFlex - Lars Edition",
      "author": [],
      "contents": "\r\nPhenoFlex is a phenology model (Luedeling et al., 2021), accessible via the chillR package (Luedeling et al., 2023). During my PhD I mainly worked with PhenoFlex and worked out custimized functions. These functions made it easier for me to work with PhenoFlex, for example to integrate different calibration methods, calibration algortihms or to fit several phenological stages in one go.\r\nThe standard PhenoFlex routines, from running the model, calibrating it, cross-validation and plotting the outputs of the chill and heat accumulation submodels is already nicely documented by Urbach et al. (2021), see https://cran.r-project.org/web/packages/chillR/vignettes/PhenoFlex.html. These routines were the blueprint for the first phenology studies using PhenoFlex (Fernandez et al., 2022; Luedeling et al., 2021).\r\nIn these studies, many iterations of model calibration were carried out. That means you run the calibration fitting function chillR::PhenologyFitter(), wait and check if the estimated model parameters provide better predictions, if yes, then you start another round of calibration, using the estimated parameters as a new starting point. If they did not improve the predictions, you may want to change the search space, either make them wider or narrower to help the optimization algorithm to find new sets of parameters. 15 to 30 rounds of iterations were used to find the final set of parameters. This workflow resulted in fairly good parameters, the validation RMSE was below 4 days in these studies, however, it is a lot of work and takes quite a while. And most importantly, it is difficult to scale up the process, because it involves a lot of manual checking, adjusting search ranges, checking temperature response plots.\r\nOne of my first tasks as a PhD was to apply PhenoFlex to an extensive phenology dataset assembled in the Adapting Mediterranean Orchards (AdaMedOr) project (Luedeling et al., 2024). The dataset comprised 270 cultivars of seven temperate fruit tree species (almond, pistachio, apple, pear, plum, sweet cherry, apricot). More than 100 cultivars had 20 or more observations (Caspersen et al., 2025), which is deemed to be the critical number of observations for model calibration (Urbach et al., 2021). For most of the cultivars we had 20 observations, so after a 75% calibration - 25% validation split only 5 observations are in the validation data set. Validating the model only on 5 observations seems quite a stretch, so we wanted to cross-validate the calibrated the model, so we had to even do more calibration steps.\r\nIntermediate chill submodel parameters\r\nTogether with Jose Egea, member of the AdaMedOr project consortium and experienced in global optimization problems, we hypothesized that part of the calibration problem are the ranges of the model parameters. In particular the parameters controlling the chill submodel. The Dynamic Model (Fishman et al., 1987a, 1987b) consists of two ordinary differential equation (ODE) modeling the build-up and degradation of some (hypothetical) precursor of a dormancy breaking factor (PDBF). After a critical amount of PDBF is accumulated, a certain share gets converted to a non-degradable dormancy breaking factor (DBF). For the ODEs controlling build-up and degradation of PDBF four parameters are needed: \\(E_0\\): activation energy for forming PDBF, \\(A_0\\): amplitude of the formation process, \\(E_1\\): activation energy for degrading PDBF and \\(A_1\\): amplitude of the degradation process. All of these parameters are not really tangible for most people, so setting boundaries is difficult. It is even more difficult, because the default value of \\(A_1\\) for example is on a ridiculous scale, 5.939917e13, that is a number wit 13 zeros before the digit! Good luck finding an appropriate search space that does not limit the algorithm too much but still is manageable. By the way, the default search space in Urbach et al. (2021) might be too narrow, as in the original paper describing the Dynamic Model parameter they ranged from 0.1797e15 to 0.1875e17, while there the search space is ‚Äúonly‚Äù between 5.e13 to 6.e13. Also, they had initially ridiculous ranges in the other estimated model parameters, for instance \\(A_0\\) ranged from 0.1386e4 to 0.1405e15. So in summary, finding appropriate ranges for these parameters is a difficult task, and even if you find them, it is a difficult search space for the optimization algorithm to navigate. Based on my limited experience, the optimizer is often ‚Äústuck‚Äù for these parameters and does not offer different sets of parameters for \\(E_0\\), \\(E_1\\), \\(A_0\\) and \\(A_1\\).\r\nEgea et al. (2021) point out, that the \\(E_0\\) to \\(A_1\\) parameters of the Dynamic Model get actually calculated based on a set of more tangible parameters, describing the experimental set-up, that serves as a basis of the Dynamic Model. These intermediate parameters are according to Fishman et al. (1987b): \\(\\theta^{*}\\): the temperature, leading to a maximal chilling effect, \\(\\theta_c\\) the highest temperature which still gives a positive response, \\(\\tau\\): the time needed to accumulate one critical portion of DBF under optimal temperature conditions and \\(\\pi_c\\) and the length of the cycle in a two-temperature regime, which leads to complete chilling negation.\r\nOther parameters describing the experiment, include the alternated temperatures of the experiment (\\(\\theta_1=297K\\), \\(\\theta_2=279K\\)), and the fixed relation of these two temperatures (\\(\\eta = \\frac{1}{3}\\)). The \\(E_0\\) to \\(A_1\\) parameters get estimated on \\(\\theta^{*}\\), \\(\\theta_c\\), \\(\\tau\\) and \\(\\pi_c\\) So Egea et al. (2021) proposed run a global optimization procedure on the intermediate parameters instead, because they are measured in Kelvin and hours, and boundaries of the search space are easier to set. Unfortunately, this involved to dig through some nasty looking equations, check out Egea et al. (2021) and the original publication of the Dynamic Model, equations 33 to 38 (Fishman et al., 1987b). In the end, a clean conversion is not possible for \\(A_1\\) and \\(A_0\\), they need to be estimated using an optimization problem.\r\nHere is the set of equations that need to be solved (taken from Egea et al. (2021)):\r\n\\[\r\n\\begin{align*}\r\nE_1=\\frac{E_0-E_1}{e^{(E_1-E_0)*q}-1}*\\frac{1}{ln(1-e^{(E_0-E1)*q})}\\\\\r\nA_1=-e^{\\frac{E_1}{\\theta^{*}}}*\\frac{ln(1-e^{(E_0-E_1)*q})}{\\tau}\\\\\r\nA_0=A_1e^{(\\frac{E_0-E_1}{\\theta_c})}\\\\\r\n\\frac{e^{(\\frac{E_1-E_0}{\\theta_c})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}{e^{(\\frac{E_1-E_0}{\\theta_2})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}=\\frac{1-e^{-(k_1(\\theta_2)*(1-\\eta)*\\pi_c)}}{1-e^{-([k_1(\\theta_1)*\\eta+k_1(\\theta_2)*(1-\\eta)]*\\pi_c)}}\\\\\r\n\\text{with } q=\\frac{1}{\\theta^{*}}+\\frac{1}{\\theta_c}\\text{; }\\theta_1=297K\\text{; }\\theta_2=279K\\text{; }\\eta=\\frac{1}{3}\r\n\\end{align*}\r\n\\]\r\nTo convert the intermediate model parameters, you can use the function LarsChill::convert_parameters(). It is written to take all 12 PhenoFlex model parameters, because at the time that was the easiest way for me to implement it. But it only affects the four intermediate model parameters\r\nHere is an example\r\n\r\n\r\n#       yc   zc   s1   Tu  theta_star theta_c tau  pie_cTf Tu Tb slope\r\npar <- c(40, 190, 0.5, 25,  281,      287,     30, 24,  4, 36,  4,  1.60)\r\nLarsChill::convert_parameters(par)\r\n\r\n [1] 4.000000e+01 1.900000e+02 5.000000e-01 2.500000e+01 4.457844e+03\r\n [6] 1.016131e+04 4.197532e+05 1.793094e+14 4.000000e+00 3.600000e+01\r\n[11] 4.000000e+00 1.600000e+00\r\n\r\nLuckily, this is also what Fishman et al. (1987b) calculated for these sets of intermediate parameters, so it seems that the function is working alright (if you want to compare, check first row of Table 1, Fishman et al. (1987b)).\r\nBecause A0 and A1 get estimated using an optimization problem, it could theoretically happen that the optimization algorithm fails or that no solution is available. This can be problematic inside an optimization algorithm, so I included options how to handle such a failure to converge. Check details of the failure_return argument.\r\nYou need to adjust the evaluation functions if you want to use the intermediate model parameters in your optimization problem. Conveniently, PhenoFlex was coded in a modular way, so that evaluation functions can be modified. Inconveniently, PhenoFlex has a quite nested code structure, so that it is at first a bit challenging to find out what exactly needs to be adjusted. The argument modelfn of the phenologyFitter() function controls the function, that calculates bloom dates based on the supplied temperature data and parameters. If we want to exchange the \\(E_0\\) to \\(A_1\\) parameters with the intermediate ones, adjusting the input of the modelfn argument is the way to go.\r\n\r\n\r\nchillR::PhenoFlex_GDHwrapper\r\n\r\nfunction (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n<bytecode: 0x0000021111f03c30>\r\n<environment: namespace:chillR>\r\n\r\nAs you can see, the PhenoFlex_GDHwrapper wrapper is a relatively simple funciton. It takes x and par as inputs. x should be of the same format as tge output of the chillR::genSeasonList() function, it produces a list of data.frames, each data.frame has three columns: ‚ÄòTemp‚Äô, ‚ÄòJDay‚Äô and ‚ÄòYear‚Äô. par is a numeric vector with twelve entries, containing the PhenoFlex model parameters. Pay attention, that the order of parameters is correct, otherwise the function may not work or produce funny results. The first par of the code ensures that temperatures of the heat submodel make sense, the base temperature \\(T_b\\) must be lower than optimal temperature \\(T_u\\) and secondly, \\(T_u\\) should not be larger than the critical temperature \\(T_c\\). The next part of the code inserts the model parameters and the temperature data into PhenoFlex. PhenoFlex returns the bloomindex, this is not the bloom date but indicates at which row of the temperature data.frame x the accumulated heat exceeds the heat requirement \\(z_c\\). The last part of the code calculates the bloom date, it has a routine what to do when the accumulated heat never exceeds \\(z_c\\) (it returns an NA to the phenologyFitter() function) or it calculates the Julian Day (with digits). The bloom date calculation looks at first glance a bit complicated, but it accounts for the hour when the requirement is met. When it is met at noon at 12:00, it returns the Julian Day without alteration. If it is earlier, it subtracts a fraction and if it is later than noon it adds a fraction.\r\nHere is an example with intermediate model parameters:\r\n\r\n\r\nPhenoFlex_GDHwrapper_adjusted <- function (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n  \r\n  #convert bloom dates\r\n  par_converted <- LarsChill::convert_parameters(par)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par_converted[1], zc = par_converted[2], s1 = par_converted[3], Tu = par_converted[4], E0 = par_converted[5], \r\n        E1 = par_converted[6], A0 = par_converted[7], A1 = par_converted[8], Tf = par_converted[9], Tc = par_converted[10], \r\n        Tb = par_converted[11], slope = par_converted[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nDownside of this approach is, that the conversion happens for each bloom date calculation seperately. But it would be necissary to convert it once and then calculate bloom dates for all the SeasonList entries. Unfortunately, the modelfn argument is the only way to customize the functions without having to build a whole custom version of phenologyFitter() function. I address this shortcoming in the chapter on customized model calibration.\r\nIntermediate chill submodel parameters\r\nAdjusting the GDH-wrapper function is also the easiest way to fix model parameters. Here is an example with \\(T_c\\) fixed at 36¬∞C. Now par should have only 11 entries, because we fixed Tc. Pay attention, that you incert the fixed parameters at the right position or correct the indices in the later code, so that the parameters are assigned correctly in the PhenoFlex function call. You can of course fix more model parameters, if you want to. Also, make sure that you remove the fixed parameter from par.guess and the search ranges when running the phenologyFitter() function.\r\n\r\n\r\nPhenoFlex_GDHwrapper_fixed <- function (x, par, Tc = 36) \r\n{\r\n  par <- c(par[1:9], Tc, par[10:11])\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nAlternative optimization algorithm MEIGO with additional parameter constraints\r\nAs you can see, customizing the evaluation function is relatively simple. It gets a bit more complicated when you want to try out a different optimization algorithm than the simulated annealing function, implemented in the phenologyFitter() function. For example, I wanted to use the optimization framework MEIGO (Egea et al., 2014). MEIGO is also available on bioconductor, a platform where you can access R packages similar to CRAN. The installation via bioconductor is in my opinion less convenient than via CRAN and installing MEIGOR package was error-prone. As a quick fix, I mirrored the core of the MEIGOR package in my custom R package LarsChill (quite an original name, I know) https://github.com/larscaspersen/addition_chillR. Here you can find the original vignette for MEIGOR: https://www.bioconductor.org/packages/release/bioc/manuals/MEIGOR/man/MEIGOR.pdf. I only took the function for the Enhanced Scatter Search (ESS), which you can find via LarsChill::custom_essr(), but the functionality is just the same as in the original MEIGOR package.\r\nThe ESS has some advantages and disadvantages compared to the simulated annealing algorithm. It was developed for complex optimization problems, it allows to screen for many different sets of model parameters, something I had the feeling the standard phenologyFitter() function was lacking. It is also relatively fast for small datasets (with <100 observations). You can specify additional inequality constraints when setting up the optimization problem. As you saw in the previous example, also the GDH_wrapper has some additional constraints implemented, but MEIGOR makes these easier to detect and to adjust and it also allows to specify acceptable ranges. I also like, that the function returns all the intermediate solutions that were surpassed by other sets of parameters in the course of the optimization run, it also returns the intermediate error scores, convenient if you want to make sure that the algorithm has converged or not. A big disadvantage is, that the speed of the ESS algorithm deteriorates quite fast for larger datasets, so if you have lots of observations in the calibration dataset it is better to stick with the simulated annealing algorithm used in the phenologyFitter function.\r\nTo optimize PhenoFlex with another algorithm involves a little bit more work. The ESS optimization algorithm needs a function that calculates the model error for a particular set of parameters and temperature data. In most optimization problems model error is measured as Residual Sum of Squares (RSS), which is in our case simply the sum of the squared differences between predicted and observed bloom dates. The PhenoFlex_GDH_wrapper() function, however, only returns the bloom date for one season of temperatures and it does not even compare the prediction to the observed bloom dates. The function taking care of calculating the RSS is a hidden function called chillR:::chifull(). Note that I used three colons, when referring to the function, because this notation allows to access ‚Äúhidden‚Äù functions, that did not get exported when creating the chillR package.\r\nI decided to maintain the modular structure of the phenologyFitter() function, where you specify the function how to calculate a bloom date with the modelfn argument, like with the PhenoFlex_GDH_wrapper() function. The evaluation function needs to do three things:\r\ncalculate bloom dates based on the temperature data specifeid in SeasonList\r\ncalculate RSS by comparing the predicted bloom dates with the observed ones, specified in bloomJDays\r\ncheck model parameters for additional constraints\r\nHere is an example of an evaluation function, that is compatible with the ESS algorithm of MEIGOR. I tried to\r\nbundle all the different cusotm evaluaiton functions and wrapper functions in a seperate package called\r\nevalpheno, you can find the package here: https://github.com/larscaspersen/eval_phenoflex\r\n\r\n\r\nevalpheno::evaluation_function_meigo\r\n\r\nfunction (x, modelfn, bloomJDays, SeasonList, na_penalty = 365) \r\n{\r\n    par <- x\r\n    pred_bloom <- unlist(lapply(X = SeasonList, FUN = modelfn, \r\n        par = par))\r\n    pred_bloom <- ifelse(is.na(pred_bloom), yes = na_penalty, \r\n        no = pred_bloom)\r\n    F <- sum((pred_bloom - bloomJDays)^2)\r\n    g <- rep(0, 5)\r\n    g[1] <- x[4] - x[11]\r\n    g[2] <- x[10] - x[11]\r\n    g[3] <- x[10] - x[4]\r\n    g[4] <- exp((10 * x[5])/(297 * 279))\r\n    g[5] <- exp((10 * x[6])/(297 * 279))\r\n    return(list(F = F, g = g))\r\n}\r\n<bytecode: 0x000002111cc22550>\r\n<environment: namespace:evalpheno>\r\n\r\nAs you can see, the evaluation functions is actually quite simple. At first we predict bloom dates, using the entries of SeasonList, t the function to calculate bloom dates specified in modelfn and the parameters specified in x(in the vignette for the MEIGOR package they always called the vector of the parameter x, while in PhenoFlex it is the name for the temperature data. Because I was not sure if the naming affected something, I followed the naming convention of the vignette, though it might be confusing.).\r\nIn case there is an NA in the predicted bloom dates, the value gets replaced with a value specified in na_penalty. Next, predicted and observed bloom dates get compared and the RSS is calculated and saved in the object F. The last and longest part is about the inequality constraints. The first three of the constrains should be familiar, as they are the same as in the PhemoFlex_GDH_wapper() function. Constrains 4 and 5 are new, relate to the \\(Q_{10}\\) metric, that expresses by which factor a biological process speeds up for an increase in temperature by 10¬∞C (Hegarty, 1973). In biological systems \\(Q_{10}\\) values of 1.5 to 3.5 are deemed realisitic (Egea et al., 2021). In the early PhenoFlex papers (Fernandez et al., 2022; Luedeling et al., 2021) the \\(Q_{10}\\) metric was checked after the calibration, but I think it makes even more sense to check the metric during the calibration. The results of the inequality constraints get saved in the vector g. Both, the error function F and the results of the inequality constrains g get returned to the optimization function.\r\nBefore running the optimization function, we can specify acceptable upper and lower ranges for the inequality constrains, similar to how you do it for the search space of the model parameters.\r\nHere is an example of the specifications I made when calibrating PhenoFlex for a large dataset of temperate fruit trees (Caspersen et al., 2025):\r\n\r\n\r\n#search space of model parameters\r\n#        yc      zc     s1      Tu      theta_c   tau      piec    Tf     Tb     slope\r\nx_0 <- c(24.79,  337.04,  0.2529,  17.72,  285.54,     45.67,    29.49,  2.97,  1.87,  2.69)\r\nx_U <- c(80,    500,    1.0,    30,     287,       48,      50,    10,    10,     5.00)\r\nx_L <- c(20,    100,    0.1,    15,     284,       16,      24,     2,     2,     1.2)\r\n\r\n#limits for the inequality constraints\r\n#         #gdh parameters   #q10 for E0 and E1\r\nc_L <- c(  0,   0,   0,     1.5, 1.5)\r\nc_U <- c(Inf, Inf, Inf,     3.5, 3.5)\r\n\r\nproblem<-list(f=\"evalpheno::eval_phenoflex_single_twofixed\",\r\n              x_0 = x_0,\r\n              x_L = x_L,\r\n              x_U = x_U,\r\n              c_L = c_L, \r\n              c_U = c_U)\r\n\r\n\r\n#options for fitter\r\nopts<-list(#maxeval = 1000,\r\n  maxtime = 60 * 10, \r\n  local_solver = 'DHC', \r\n  local_bestx = 1)\r\n\r\nLarsChill::custom_essr(problem = problem,\r\n                       opts = options,\r\n                       modelfn = custom_PhenoFlex_GDHwrapper,\r\n                       bloomJDays = pheno,\r\n                       SeasonList = season_cal_list)\r\n\r\n\r\nThe first part is about the search space of the model parameters. I decided to optimize based on the intermediate model parameters and to fix two of the model parameters (\\(\\theta^{*} = 279\\), \\(T_c=36\\)). x_0 is the initial guess, x_L the lower search range and x_U the upper range. The upper acceptable limit of the inequality constrain is specified in c_U and the lower limit in c_L. In the first three constrains for the heat submodel temperature parameters, we excluded any negative value, in the last two relating to the \\(Q_{10}\\) metric, we excluded values outside the range of 1.5 to 3.5. All of that information is bundled in a list called problem. There it is also specified which evaluation function we are using, here I use the function evalpheno::eval_phenoflex_single_twofixed. Make sure that you omit the paranthesis after function name, because you want to only specify the name and not exexcute the function. The problem-list gets followed by the option list, here you specify settings of the optimization algorithm. maxtime specifies the time-limit for how long the algortihm should optimize (in seconds). local_solver specifies which optimization algorithm should be run when ESS found a set of model parameter leading to a lower RSS. The local solver makes a more refined narrower search around the newly found, better model parameters. local_bestx specifies how often the local search is called. When set to 1, local search is only triggered immediately after a better set is found, higher values would postpone the local search for some further iterations, that can be beneficial when the global search quickly finds even better parameter sets. You can also specifiy how many iterations the algorithms should make with maxeval. For more options, check the MEIGOR vignette.\r\nLastly, the problem and option list get supplied to the LarsChill::custom_essr() funciton. This function does the optimization and should hopefully return good model parameters for your dataset. As you may have noticed, I also supplied three further arguments to the function: modelfn, bloomJDays and SeasonList. These are inputs for the evaluation function specified in the problem list. They are the same when running the phenologyFitter() function.\r\nShared chill and heat accumulation submodels but cultivar-specific requirement parameters: The combined fitting approach\r\n\r\n\r\n\r\nCaspersen, L., Schiffers, K., Picornell, A., Egea, J.A., Delgado, A., El Yaacoubi, A., Benmoussa, H., Rodrigo, J., Fad√≥n, E., Ben Mimoun, M., Ghrab, M., Kodad, O., Ruiz, D., Luedeling, E., 2025. Contrasting Responses to Climate Change ‚Äì Predicting Bloom of Major Temperate Fruit Tree Species in the Mediterranean Region and Central Europe. https://doi.org/10.2139/ssrn.5106075\r\n\r\n\r\nEgea, J.A., Egea, J., Ruiz, D., 2021. Reducing the uncertainty on chilling requirements for endodormancy breaking of temperate fruits by data-based parameter estimation of the dynamic model: A test case in apricot. Tree Physiology 41, 644‚Äì656. https://doi.org/10.1093/treephys/tpaa054\r\n\r\n\r\nEgea, J.A., Henriques, D., Cokelaer, T., Villaverde, A.F., MacNamara, A., Danciu, D.-P., Banga, J.R., Saez-Rodriguez, J., 2014. MEIGO: An open-source software suite based on metaheuristics for global optimization in systems biology and bioinformatics. BMC Bioinformatics 15, 136. https://doi.org/10.1186/1471-2105-15-136\r\n\r\n\r\nFernandez, E., Schiffers, K., Urbach, C., Luedeling, E., 2022. Unusually warm winter seasons may compromise the performance of current phenology models ‚Äì Predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology 322, 109020. https://doi.org/10.1016/j.agrformet.2022.109020\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987a. The temperature-dependence of dormancy breaking in plants - computer-simulation of processes studied under controlled temperatures. Journal of Theoretical Biology 126, 309‚Äì321. https://doi.org/10.1016/s0022-5193(87)80237-0\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987b. The temperature dependence of dormancy breaking in plants: Mathematical analysis of a two-step model involving a cooperative transition. Journal of Theoretical Biology 124, 473‚Äì483. https://doi.org/10.1016/S0022-5193(87)80221-7\r\n\r\n\r\nHegarty, T.W., 1973. Temperature Coefficient (Q10), Seed Germination and Other Biological Processes. Nature 243, 305‚Äì306. https://doi.org/10.1038/243305a0\r\n\r\n\r\nLuedeling, E., Caspersen, L., Delgado, A., Egea, J.A., Ruiz, D., Ben Mimoun, M., Benmoussa, H., Ghrab, M., Kodad, O., El Yaacoubi, A., Fad√≥n, E., Rodrigo, J., 2024. Long-term phenology observations for temperate fruit trees in the Mediterranean region (and Germany).\r\n\r\n\r\nLuedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical Methods for Phenology Analysis in Temperate Fruit Trees.\r\n\r\n\r\nLuedeling, E., Schiffers, K., Fohrmann, T., Urbach, C., 2021. PhenoFlex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n\r\n\r\nUrbach, C., Luedeling, E., Schiffers, K., 2021. PhenoFlex - vignette within the chillR package.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-27T15:39:27+01:00"
    }
  ],
  "collections": []
}
