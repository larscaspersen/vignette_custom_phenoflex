{
  "articles": [
    {
      "path": "fixing-parameters-before-calibration.html",
      "title": "Fixing Parameters Before Calibration",
      "author": [],
      "contents": "\r\nFixing model parameters to default values and excluding them from the model calibration is relatively easy in PhenoFlex. This is thanks to the modular structure of the chillR::phenologyFitter() function. Modifying the input for the modelfn argument does the trick. By default it is set to PhenoFlex_GDHwrapper. This is the name of a function in the chillR package. The help page of the chillR::phenologyFitter() function says, that the modelfn argument is a “[…] Model function which computes the index in ‘temperatures’ at which blooming occures. It must have as first argument a data frame with at least the two columns ‘Temp’ and ‘JDays’ for one season, see ‘SeasonList’. It can have further arguments which can be passed via ‘…’. The ‘modelfn’ must return a single numeric value for the predicted bloom JDay for that season. ‘NA’ is an allowed return value if no blooming occures in that season. The default is the PhenoFlex with GDH as heat accumulation. Alternative is PhenoFlex_GAUSSwrapper with GAUSSian heat accumulation. But this function can also be user defined.”\r\nIn essence, the function needs to be able to calculate the bloom date for a data.frame with temperature data for one season (argument x) and for a paticular set of model parameters (argument par). Here is how the default function looks like:\r\n\r\n\r\nchillR::PhenoFlex_GDHwrapper\r\n\r\nfunction (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n<bytecode: 0x000001a5d14a2c50>\r\n<environment: namespace:chillR>\r\n\r\nAs you can see, the PhenoFlex_GDHwrapper wrapper is a relatively simple funciton. It takes x and par as inputs. x should be of the same format as tge output of the chillR::genSeasonList() function, it produces a list of data.frames, each data.frame has three columns: ‘Temp’, ‘JDay’ and ‘Year’. par is a numeric vector with twelve entries, containing the PhenoFlex model parameters. Pay attention, that the order of parameters is correct, otherwise the function may not work or produce funny results. The first par of the code ensures that temperatures of the heat submodel make sense, the base temperature \\(T_b\\) must be lower than optimal temperature \\(T_u\\) and secondly, \\(T_u\\) should not be larger than the critical temperature \\(T_c\\). The next part of the code inserts the model parameters and the temperature data into PhenoFlex. PhenoFlex returns the bloomindex, this is not the bloom date but indicates at which row of the temperature data.frame x the accumulated heat exceeds the heat requirement \\(z_c\\). The last part of the code calculates the bloom date, it has a routine what to do when the accumulated heat never exceeds \\(z_c\\) (it returns an NA to the phenologyFitter() function) or it calculates the Julian Day (with digits). The bloom date calculation looks at first glance a bit complicated, but it accounts for the hour when the requirement is met. When it is met at noon at 12:00, it returns the Julian Day without alteration. If it is earlier, it subtracts a fraction and if it is later than noon it adds a fraction.\r\nCustomizing the wrapper function\r\nThe requirements on the wrapper function supplied in modelfn are relatively loose. It was never specified, for example, how many parameters need to be supplied and in which order. When we want to exclude some model parameters from calibration, maybe because we noted that they contribute relatively little to the model performance, then we can adjust how we insert the model parameters of par in the chillR::PhenoFlex() function.\r\nHere is an example with \\(T_c\\) fixed at 36°C. Now par should have only 11 entries, because we fixed Tc. Pay attention, that you incert the fixed parameters at the right position or correct the indices in the later code, so that the parameters are assigned correctly in the PhenoFlex function call. You can of course fix more model parameters, if you want to. Also, make sure that you remove the fixed parameter from par.guess and the search ranges when running the phenologyFitter() function.\r\n\r\n\r\nPhenoFlex_GDHwrapper_fixed <- function (x, par, Tc = 36) \r\n{\r\n  par <- c(par[1:9], Tc, par[10:11])\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nWe have adjusted the wrapper function! And now what? Next time we want to calibrate the model with \\(T_c\\) fixed at 36°C (or any other value), we can use PhenoFlex_GDHwrapper_fixed as an argument for modelfn when running the chillR::phenologyFitter() function. Just make sure that you remove \\(T_c\\) from the par.guess, lower and upper argument, when running the function. Here is an example code from the help page of the chillR::phenologyFitter() function, that I modified to keep \\(T_c\\) fixed at 36°C.\r\n\r\n\r\ndata(KA_weather)\r\ndata(KA_bloom)\r\nhourtemps <- stack_hourly_temps(KA_weather, latitude=50.4)\r\nSeasonList <- genSeasonList(hourtemps$hourtemps, years=c(2007,2008))\r\n#remove Tc from par.guess, upper and lower\r\n#--> only 11 parameters to estimate\r\n#       yc    zc   s1  Tu  E0      E1      A0      A1           Tf Tb slop  \r\npar <- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 4, 1.6)\r\nupper <- c(41, 200, 1, 30, 4000, 10000, 7000, 6.e13, 10, 10, 50)\r\nlower <- c(38, 180, 0.1, 0, 3000, 9000, 6000, 5.e13, 0, 0, 0.05)\r\nX <- phenologyFitter(par.guess=par, bloomJDays=KA_bloom$pheno[c(24,25)], \r\n  SeasonList=SeasonList, lower=lower, upper=upper,\r\n  control=list(smooth=FALSE, verbose=TRUE, maxit=10, nb.stop.improvement=5))\r\nsummary(X)\r\nplot(X)\r\n\r\n\r\nIt is quite convenient, that we choose to have the fixed parameter as an additional model argument. If we later change our mind and want to keep \\(T_c\\) fixed at 30°C instead of the default 36°C, we only need to add that information in the function call of the chillR::phenologyFitter(). If we forgot to specify the default value as an argument of the function, we would be forced to either change the code specifying the modelfn function or create an alternative version. Quite messy. But because we kept Tc as a function argument, with a default value of 36, we can pass different values for \\(T_c\\) via the chillR::phenologyFitter() function. We can do that, thanks to the magic of the ... argument of the chillR::phenologyFitter(). As far as I understand it, the ... argument takes any named or unnamed additional argument, that is not specified when the function is defined. And the fitter function is coded in a way, that all these additional arguments are passed on to the modelfn function. Just make sure that you name the argument correctly, so that the function can assign it to the function specified in modelfn.\r\n\r\n\r\ndata(KA_weather)\r\ndata(KA_bloom)\r\nhourtemps <- stack_hourly_temps(KA_weather, latitude=50.4)\r\nSeasonList <- genSeasonList(hourtemps$hourtemps, years=c(2007,2008))\r\n#remove Tc from par.guess, upper and lower\r\n#--> only 11 parameters to estimate\r\n#       yc    zc   s1  Tu  E0      E1      A0      A1           Tf Tb slop  \r\npar <- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 4, 1.6)\r\nupper <- c(41, 200, 1, 30, 4000, 10000, 7000, 6.e13, 10, 10, 50)\r\nlower <- c(38, 180, 0.1, 0, 3000, 9000, 6000, 5.e13, 0, 0, 0.05)\r\nX <- phenologyFitter(par.guess=par, bloomJDays=KA_bloom$pheno[c(24,25)], \r\n  SeasonList=SeasonList, lower=lower, upper=upper,\r\n  Tc = 30,\r\n  control=list(smooth=FALSE, verbose=TRUE, maxit=10, nb.stop.improvement=5))\r\nsummary(X)\r\nplot(X)\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-27T16:58:31+01:00"
    },
    {
      "path": "implement-meigo.html",
      "title": "Implementing Alternative Calibration Algortihms",
      "author": [],
      "contents": "\r\nMotivation\r\nThe chapters on fixing model parameters and introducing intermediate parameters showed that customizing the evaluation function is relatively simple. It gets a bit more complicated when you want to try out a different optimization algorithm than the simulated annealing function, implemented in the phenologyFitter() function. For example, I wanted to use the optimization framework MEIGO (Egea et al., 2014). MEIGO is also available on bioconductor, a platform where you can access R packages similar to CRAN. The installation via bioconductor is in my opinion less convenient than via CRAN and installing MEIGOR package was error-prone. As a quick fix, I mirrored the core of the MEIGOR package in my custom R package LarsChill (quite an original name, I know) https://github.com/larscaspersen/addition_chillR. Here you can find the original vignette for MEIGOR: https://www.bioconductor.org/packages/release/bioc/manuals/MEIGOR/man/MEIGOR.pdf. I only took the function for the Enhanced Scatter Search (ESS), which you can find via LarsChill::custom_essr(), but the functionality is just the same as in the original MEIGOR package.\r\nThe ESS has some advantages and disadvantages compared to the simulated annealing algorithm. It was developed for complex optimization problems, it allows to screen for many different sets of model parameters, something I had the feeling the standard phenologyFitter() function was lacking. It is also relatively fast for small datasets (with <100 observations). You can specify additional inequality constraints when setting up the optimization problem. As you saw in the previous example, also the GDH_wrapper has some additional constraints implemented, but MEIGOR makes these easier to detect and to adjust and it also allows to specify acceptable ranges. I also like, that the function returns all the intermediate solutions that were surpassed by other sets of parameters in the course of the optimization run, it also returns the intermediate error scores, convenient if you want to make sure that the algorithm has converged or not. A big disadvantage is, that the speed of the ESS algorithm deteriorates quite fast for larger datasets, so if you have lots of observations in the calibration dataset it is better to stick with the simulated annealing algorithm used in the phenologyFitter function.\r\nImplementing a new optimization algortihm for PhenoFlex is quite messy\r\nTo optimize PhenoFlex with another algorithm involves a little bit more work. The ESS optimization algorithm needs a function that calculates the model error for a particular set of parameters and temperature data. In most optimization problems model error is measured as Residual Sum of Squares (RSS), which is in our case simply the sum of the squared differences between predicted and observed bloom dates. The PhenoFlex_GDH_wrapper() function, however, only returns the bloom date for one season of temperatures and it does not even compare the prediction to the observed bloom dates. The function taking care of calculating the RSS is a hidden function called chillR:::chifull(). Note that I used three colons, when referring to the function, because this notation allows to access “hidden” functions, that did not get exported when creating the chillR package.\r\nI decided to maintain the modular structure of the phenologyFitter() function, where you specify the function how to calculate a bloom date with the modelfn argument, like with the PhenoFlex_GDH_wrapper() function. The evaluation function needs to do three things:\r\ncalculate bloom dates based on the temperature data specifeid in SeasonList\r\ncalculate RSS by comparing the predicted bloom dates with the observed ones, specified in bloomJDays\r\ncheck model parameters for additional constraints\r\nHere is an example of an evaluation function, that is compatible with the ESS algorithm of MEIGOR. I tried to\r\nbundle all the different cusotm evaluaiton functions and wrapper functions in a seperate package called\r\nevalpheno, you can find the package here: https://github.com/larscaspersen/eval_phenoflex\r\n\r\n\r\nevalpheno::evaluation_function_meigo\r\n\r\nfunction (x, modelfn, bloomJDays, SeasonList, na_penalty = 365) \r\n{\r\n    par <- x\r\n    pred_bloom <- unlist(lapply(X = SeasonList, FUN = modelfn, \r\n        par = par))\r\n    pred_bloom <- ifelse(is.na(pred_bloom), yes = na_penalty, \r\n        no = pred_bloom)\r\n    F <- sum((pred_bloom - bloomJDays)^2)\r\n    g <- rep(0, 5)\r\n    g[1] <- x[4] - x[11]\r\n    g[2] <- x[10] - x[11]\r\n    g[3] <- x[10] - x[4]\r\n    g[4] <- exp((10 * x[5])/(297 * 279))\r\n    g[5] <- exp((10 * x[6])/(297 * 279))\r\n    return(list(F = F, g = g))\r\n}\r\n<bytecode: 0x000002c2c4174300>\r\n<environment: namespace:evalpheno>\r\n\r\nAs you can see, the evaluation functions is actually quite simple. At first we predict bloom dates, using the entries of SeasonList, t the function to calculate bloom dates specified in modelfn and the parameters specified in x(in the vignette for the MEIGOR package they always called the vector of the parameter x, while in PhenoFlex it is the name for the temperature data. Because I was not sure if the naming affected something, I followed the naming convention of the vignette, though it might be confusing.).\r\nIn case there is an NA in the predicted bloom dates, the value gets replaced with a value specified in na_penalty. Next, predicted and observed bloom dates get compared and the RSS is calculated and saved in the object F. The last and longest part is about the inequality constraints. The first three of the constrains should be familiar, as they are the same as in the PhemoFlex_GDH_wapper() function. Constrains 4 and 5 are new, relate to the \\(Q_{10}\\) metric, that expresses by which factor a biological process speeds up for an increase in temperature by 10°C (Hegarty, 1973). In biological systems \\(Q_{10}\\) values of 1.5 to 3.5 are deemed realisitic (Egea et al., 2021). In the early PhenoFlex papers (Fernandez et al., 2022; Luedeling et al., 2021) the \\(Q_{10}\\) metric was checked after the calibration, but I think it makes even more sense to check the metric during the calibration. The results of the inequality constraints get saved in the vector g. Both, the error function F and the results of the inequality constrains g get returned to the optimization function.\r\nBefore running the optimization function, we can specify acceptable upper and lower ranges for the inequality constrains, similar to how you do it for the search space of the model parameters.\r\nWorkflow using ESS algorithm\r\nHere is an example of the specifications I made when calibrating PhenoFlex for a large dataset of temperate fruit trees (Caspersen et al., 2025):\r\n\r\n\r\n#search space of model parameters\r\n#        yc      zc     s1      Tu      theta_c   tau      piec    Tf     Tb     slope\r\nx_0 <- c(24.79,  337.04,  0.2529,  17.72,  285.54,     45.67,    29.49,  2.97,  1.87,  2.69)\r\nx_U <- c(80,    500,    1.0,    30,     287,       48,      50,    10,    10,     5.00)\r\nx_L <- c(20,    100,    0.1,    15,     284,       16,      24,     2,     2,     1.2)\r\n\r\n#limits for the inequality constraints\r\n#         #gdh parameters   #q10 for E0 and E1\r\nc_L <- c(  0,   0,   0,     1.5, 1.5)\r\nc_U <- c(Inf, Inf, Inf,     3.5, 3.5)\r\n\r\nproblem<-list(f=\"evalpheno::eval_phenoflex_single_twofixed\",\r\n              x_0 = x_0,\r\n              x_L = x_L,\r\n              x_U = x_U,\r\n              c_L = c_L, \r\n              c_U = c_U)\r\n\r\n\r\n#options for fitter\r\nopts<-list(#maxeval = 1000,\r\n  maxtime = 60 * 10, \r\n  local_solver = 'DHC', \r\n  local_bestx = 1)\r\n\r\nLarsChill::custom_essr(problem = problem,\r\n                       opts = options,\r\n                       modelfn = custom_PhenoFlex_GDHwrapper,\r\n                       bloomJDays = pheno,\r\n                       SeasonList = season_cal_list)\r\n\r\n\r\nThe first part is about the search space of the model parameters. I decided to optimize based on the intermediate model parameters and to fix two of the model parameters (\\(\\theta^{*} = 279\\), \\(T_c=36\\)). x_0 is the initial guess, x_L the lower search range and x_U the upper range. The upper acceptable limit of the inequality constrain is specified in c_U and the lower limit in c_L. In the first three constrains for the heat submodel temperature parameters, we excluded any negative value, in the last two relating to the \\(Q_{10}\\) metric, we excluded values outside the range of 1.5 to 3.5. All of that information is bundled in a list called problem. There it is also specified which evaluation function we are using, here I use the function evalpheno::eval_phenoflex_single_twofixed. Make sure that you omit the paranthesis after function name, because you want to only specify the name and not exexcute the function. The problem-list gets followed by the option list, here you specify settings of the optimization algorithm. maxtime specifies the time-limit for how long the algortihm should optimize (in seconds). local_solver specifies which optimization algorithm should be run when ESS found a set of model parameter leading to a lower RSS. The local solver makes a more refined narrower search around the newly found, better model parameters. local_bestx specifies how often the local search is called. When set to 1, local search is only triggered immediately after a better set is found, higher values would postpone the local search for some further iterations, that can be beneficial when the global search quickly finds even better parameter sets. You can also specifiy how many iterations the algorithms should make with maxeval. For more options, check the MEIGOR vignette.\r\nLastly, the problem and option list get supplied to the LarsChill::custom_essr() funciton. This function does the optimization and should hopefully return good model parameters for your dataset. As you may have noticed, I also supplied three further arguments to the function: modelfn, bloomJDays and SeasonList. These are inputs for the evaluation function specified in the problem list. They are the same when running the phenologyFitter() function.\r\nThe ouput\r\n\r\n\r\n\r\nCaspersen, L., Schiffers, K., Picornell, A., Egea, J.A., Delgado, A., El Yaacoubi, A., Benmoussa, H., Rodrigo, J., Fadón, E., Ben Mimoun, M., Ghrab, M., Kodad, O., Ruiz, D., Luedeling, E., 2025. Contrasting Responses to Climate Change – Predicting Bloom of Major Temperate Fruit Tree Species in the Mediterranean Region and Central Europe. https://doi.org/10.2139/ssrn.5106075\r\n\r\n\r\nEgea, J.A., Egea, J., Ruiz, D., 2021. Reducing the uncertainty on chilling requirements for endodormancy breaking of temperate fruits by data-based parameter estimation of the dynamic model: A test case in apricot. Tree Physiology 41, 644–656. https://doi.org/10.1093/treephys/tpaa054\r\n\r\n\r\nEgea, J.A., Henriques, D., Cokelaer, T., Villaverde, A.F., MacNamara, A., Danciu, D.-P., Banga, J.R., Saez-Rodriguez, J., 2014. MEIGO: An open-source software suite based on metaheuristics for global optimization in systems biology and bioinformatics. BMC Bioinformatics 15, 136. https://doi.org/10.1186/1471-2105-15-136\r\n\r\n\r\nFernandez, E., Schiffers, K., Urbach, C., Luedeling, E., 2022. Unusually warm winter seasons may compromise the performance of current phenology models – Predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology 322, 109020. https://doi.org/10.1016/j.agrformet.2022.109020\r\n\r\n\r\nHegarty, T.W., 1973. Temperature Coefficient (Q10), Seed Germination and Other Biological Processes. Nature 243, 305–306. https://doi.org/10.1038/243305a0\r\n\r\n\r\nLuedeling, E., Schiffers, K., Fohrmann, T., Urbach, C., 2021. PhenoFlex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-27T17:05:47+01:00"
    },
    {
      "path": "index.html",
      "title": "Customizing PhenoFlex",
      "description": "This website collects all the different methods to tweak PhenoFlex to your needs.\n",
      "author": [
        {
          "name": "Lars Caspersen",
          "url": "https://example.com/norajones"
        }
      ],
      "date": "`r Sys.Date()`",
      "contents": "\r\n\r\n          \r\n          \r\n          Custom PhenoFlex\r\n          \r\n          \r\n          Home\r\n          \r\n          \r\n          Customized Model Calibration\r\n           \r\n          ▾\r\n          \r\n          \r\n          Overview\r\n          Fixing Model Parameters\r\n          Intermediate Model Parameters\r\n          Implement another optimization algorithm\r\n          \r\n          \r\n          Phenology Projections\r\n          Plotting\r\n          ☰\r\n          \r\n          \r\n      \r\n        \r\n          \r\n            \r\n              \r\n            \r\n              Customizing PhenoFlex\r\n            \r\n            \r\n              \r\n                \r\n                    \r\n                      \r\n                        HortiBonn\r\n                      \r\n                    \r\n                  \r\n                                    \r\n                    \r\n                      \r\n                         GitHub\r\n                      \r\n                    \r\n                  \r\n                                    \r\n                    \r\n                      \r\n                         Email\r\n                      \r\n                    \r\n                  \r\n                                  \r\n            \r\n          \r\n        \r\n        \r\n        \r\n          \r\n            \r\n            Hi and welcome, fellow phenology modeller and aspirers\r\n            to become one.\r\n            This website collects all the different methods to tweak\r\n            PhenoFlex to your needs. My name is Lars\r\n            Caspersen and I am a PhD student at the HortiBonn\r\n            group at the University of Bonn. In my PhD I focused on\r\n            phenology modeling. For that I mostly relied on PhenoFlex\r\n            (Luedeling et al., 2021) and\r\n            accessible via the chillR package (Luedeling et al., 2023). I was\r\n            asked to bundle my learning experience working with\r\n            PhenoFlex, so I decided to make this website and document my\r\n            learning experience. To make collaboration with others\r\n            easier, I bundled my customized functions in two R packages:\r\n            LarsChill\r\n            (package naming may not be my strongsuite) contains general\r\n            functions supplementing the chillR package and evalpheno\r\n            contains a collection of customized functions to calculate\r\n            bloom dates, which become handy when calibrating the\r\n            PhenoFlex model. These packages are only available via\r\n            GitHub and not via CRAN and it may happen that parts of the\r\n            functionalities get absorbed by our flagship package chillR.\r\n            This website collects all the different modifications and\r\n            custom versions of PhenoFlex that I created in the course of\r\n            my PhD. I hope it can be usefull to make my learning\r\n            experience accessible to a wider, and yet specialized,\r\n            audience. If something is not working, if something remains\r\n            unclear or you want to contact me for any other reason,\r\n            please do not be shy. You can raise issues in the GitHub\r\n            repository, that also hosts this website. You can also write\r\n            me or my supervisor Eike Luedeling a mail, for more\r\n            information check the left-hand side of the website.\r\n            This collection of vignette does not serve as a\r\n            general introduction to working with PhenoFlex. For\r\n            that, please check out this extremely helpfull vignette\r\n            on working with PhenoFlex and the course book for the\r\n            class on Tree\r\n            phenology analysis with R. Also, don’t be shy to check\r\n            out the paper\r\n            on PhenoFlex.\r\n            \r\n            Acknowledgements\r\n            I learned a lot on how to create a website like this from\r\n            the learning lockbook of Jaqueline Wingen, who participated\r\n            in the Tree Phenology Analysis with R course. Check out what\r\n            an amazing website she has build: https://jacqwng.github.io/Tree-phenology-analysis-with-R/index.html\r\n            \r\n            \r\n            References\r\n            \r\n            \r\n            Luedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical\r\n            Methods for Phenology\r\n            Analysis in Temperate\r\n            Fruit Trees.\r\n            \r\n            \r\n            Luedeling, E., Schiffers, K., Fohrmann, T., Urbach, C.,\r\n            2021. PhenoFlex - an integrated model to\r\n            predict spring phenology in temperate fruit trees.\r\n            Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n            \r\n            \r\n            \r\n            \r\n          \r\n        \r\n      \r\n    \r\n\r\n    \r\n      \r\n        \r\n          \r\n            \r\n              \r\n            \r\n              Customizing PhenoFlex\r\n            \r\n            \r\n              \r\n                \r\n                                    \r\n                    \r\n                      HortiBonn\r\n                    \r\n                  \r\n                                    \r\n                    \r\n                       GitHub\r\n                    \r\n                  \r\n                                    \r\n                    \r\n                       Email\r\n                    \r\n                  \r\n                                  \r\n              \r\n            \r\n            \r\n              \r\n              Hi and welcome, fellow phenology modeller and aspirers\r\n              to become one.\r\n              This website collects all the different methods to\r\n              tweak PhenoFlex to your needs. My name is Lars\r\n              Caspersen and I am a PhD student at the HortiBonn\r\n              group at the University of Bonn. In my PhD I focused\r\n              on phenology modeling. For that I mostly relied on\r\n              PhenoFlex (Luedeling et al.,\r\n              2021) and accessible via the chillR package (Luedeling et al., 2023). I was\r\n              asked to bundle my learning experience working with\r\n              PhenoFlex, so I decided to make this website and document\r\n              my learning experience. To make collaboration with others\r\n              easier, I bundled my customized functions in two R\r\n              packages: LarsChill\r\n              (package naming may not be my strongsuite) contains\r\n              general functions supplementing the chillR package and evalpheno\r\n              contains a collection of customized functions to calculate\r\n              bloom dates, which become handy when calibrating the\r\n              PhenoFlex model. These packages are only available via\r\n              GitHub and not via CRAN and it may happen that parts of\r\n              the functionalities get absorbed by our flagship package\r\n              chillR.\r\n              This website collects all the different modifications\r\n              and custom versions of PhenoFlex that I created in the\r\n              course of my PhD. I hope it can be usefull to make my\r\n              learning experience accessible to a wider, and yet\r\n              specialized, audience. If something is not working, if\r\n              something remains unclear or you want to contact me for\r\n              any other reason, please do not be shy. You can raise\r\n              issues in the GitHub repository, that also hosts this\r\n              website. You can also write me or my supervisor Eike\r\n              Luedeling a mail, for more information check the left-hand\r\n              side of the website.\r\n              This collection of vignette does not serve as a\r\n              general introduction to working with PhenoFlex.\r\n              For that, please check out this extremely helpfull vignette\r\n              on working with PhenoFlex and the course book for the\r\n              class on Tree\r\n              phenology analysis with R. Also, don’t be shy to check\r\n              out the paper\r\n              on PhenoFlex.\r\n              \r\n              Acknowledgements\r\n              I learned a lot on how to create a website like this\r\n              from the learning lockbook of Jaqueline Wingen, who\r\n              participated in the Tree Phenology Analysis with R course.\r\n              Check out what an amazing website she has build: https://jacqwng.github.io/Tree-phenology-analysis-with-R/index.html\r\n              \r\n              \r\n              References\r\n              \r\n              \r\n              Luedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical\r\n              Methods for Phenology\r\n              Analysis in Temperate\r\n              Fruit Trees.\r\n              \r\n              \r\n              Luedeling, E., Schiffers, K., Fohrmann, T., Urbach, C.,\r\n              2021. PhenoFlex - an integrated model to\r\n              predict spring phenology in temperate fruit trees.\r\n              Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n              \r\n              \r\n              \r\n              \r\n            \r\n        \r\n      \r\n    \r\n\r\n    \r\n    \r\n    ",
      "last_modified": "2025-03-27T17:06:58+01:00"
    },
    {
      "path": "intermediate-model-parameters.html",
      "title": "Intermediate Model Parameters",
      "author": [],
      "contents": "\r\nMotivation\r\nPhenoFlex is a phenology model (Luedeling et al., 2021), accessible via the chillR package (Luedeling et al., 2023). During my PhD I mainly worked with PhenoFlex and worked out custimized functions. These functions made it easier for me to work with PhenoFlex, for example to integrate different calibration methods, calibration algortihms or to fit several phenological stages in one go.\r\nThe standard PhenoFlex routines, from running the model, calibrating it, cross-validation and plotting the outputs of the chill and heat accumulation submodels is already nicely documented by Urbach et al. (2021), see https://cran.r-project.org/web/packages/chillR/vignettes/PhenoFlex.html. These routines were the blueprint for the first phenology studies using PhenoFlex (Fernandez et al., 2022; Luedeling et al., 2021).\r\nIn these studies, many iterations of model calibration were carried out. That means you run the calibration fitting function chillR::PhenologyFitter(), wait and check if the estimated model parameters provide better predictions, if yes, then you start another round of calibration, using the estimated parameters as a new starting point. If they did not improve the predictions, you may want to change the search space, either make them wider or narrower to help the optimization algorithm to find new sets of parameters. 15 to 30 rounds of iterations were used to find the final set of parameters. This workflow resulted in fairly good parameters, the validation RMSE was below 4 days in these studies, however, it is a lot of work and takes quite a while. And most importantly, it is difficult to scale up the process, because it involves a lot of manual checking, adjusting search ranges, checking temperature response plots.\r\nOne of my first tasks as a PhD was to apply PhenoFlex to an extensive phenology dataset assembled in the Adapting Mediterranean Orchards (AdaMedOr) project (Luedeling et al., 2024). The dataset comprised 270 cultivars of seven temperate fruit tree species (almond, pistachio, apple, pear, plum, sweet cherry, apricot). More than 100 cultivars had 20 or more observations (Caspersen et al., 2025), which is deemed to be the critical number of observations for model calibration (Urbach et al., 2021). For most of the cultivars we had 20 observations, so after a 75% calibration - 25% validation split only 5 observations are in the validation data set. Validating the model only on 5 observations seems quite a stretch, so we wanted to cross-validate the calibrated the model, so we had to even do more calibration steps.\r\nTheoretical Background\r\nTogether with Jose Egea, member of the AdaMedOr project consortium and experienced in global optimization problems, we hypothesized that part of the calibration problem are the ranges of the model parameters. In particular the parameters controlling the chill submodel. The Dynamic Model (Fishman et al., 1987a, 1987b) consists of two ordinary differential equation (ODE) modeling the build-up and degradation of some (hypothetical) precursor of a dormancy breaking factor (PDBF). After a critical amount of PDBF is accumulated, a certain share gets converted to a non-degradable dormancy breaking factor (DBF). For the ODEs controlling build-up and degradation of PDBF four parameters are needed: \\(E_0\\): activation energy for forming PDBF, \\(A_0\\): amplitude of the formation process, \\(E_1\\): activation energy for degrading PDBF and \\(A_1\\): amplitude of the degradation process. All of these parameters are not really tangible for most people, so setting boundaries is difficult. It is even more difficult, because the default value of \\(A_1\\) for example is on a ridiculous scale, 5.939917e13, that is a number wit 13 zeros before the digit! Good luck finding an appropriate search space that does not limit the algorithm too much but still is manageable. By the way, the default search space in Urbach et al. (2021) might be too narrow, as in the original paper describing the Dynamic Model parameter they ranged from 0.1797e15 to 0.1875e17, while there the search space is “only” between 5.e13 to 6.e13. Also, they had initially ridiculous ranges in the other estimated model parameters, for instance \\(A_0\\) ranged from 0.1386e4 to 0.1405e15. So in summary, finding appropriate ranges for these parameters is a difficult task, and even if you find them, it is a difficult search space for the optimization algorithm to navigate. Based on my limited experience, the optimizer is often “stuck” for these parameters and does not offer different sets of parameters for \\(E_0\\), \\(E_1\\), \\(A_0\\) and \\(A_1\\).\r\nEgea et al. (2021) point out, that the \\(E_0\\) to \\(A_1\\) parameters of the Dynamic Model get actually calculated based on a set of more tangible parameters, describing the experimental set-up, that serves as a basis of the Dynamic Model. These intermediate parameters are according to Fishman et al. (1987b): \\(\\theta^{*}\\): the temperature, leading to a maximal chilling effect, \\(\\theta_c\\) the highest temperature which still gives a positive response, \\(\\tau\\): the time needed to accumulate one critical portion of DBF under optimal temperature conditions and \\(\\pi_c\\) and the length of the cycle in a two-temperature regime, which leads to complete chilling negation.\r\nOther parameters describing the experiment, include the alternated temperatures of the experiment (\\(\\theta_1=297K\\), \\(\\theta_2=279K\\)), and the fixed relation of these two temperatures (\\(\\eta = \\frac{1}{3}\\)). The \\(E_0\\) to \\(A_1\\) parameters get estimated on \\(\\theta^{*}\\), \\(\\theta_c\\), \\(\\tau\\) and \\(\\pi_c\\) So Egea et al. (2021) proposed run a global optimization procedure on the intermediate parameters instead, because they are measured in Kelvin and hours, and boundaries of the search space are easier to set. Unfortunately, this involved to dig through some nasty looking equations, check out Egea et al. (2021) and the original publication of the Dynamic Model, equations 33 to 38 (Fishman et al., 1987b). In the end, a clean conversion is not possible for \\(A_1\\) and \\(A_0\\), they need to be estimated using an optimization problem.\r\nHere is the set of equations that need to be solved (taken from Egea et al. (2021)):\r\n\\[\r\n\\begin{align*}\r\nE_1=\\frac{E_0-E_1}{e^{(E_1-E_0)*q}-1}*\\frac{1}{ln(1-e^{(E_0-E1)*q})}\\\\\r\nA_1=-e^{\\frac{E_1}{\\theta^{*}}}*\\frac{ln(1-e^{(E_0-E_1)*q})}{\\tau}\\\\\r\nA_0=A_1e^{(\\frac{E_0-E_1}{\\theta_c})}\\\\\r\n\\frac{e^{(\\frac{E_1-E_0}{\\theta_c})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}{e^{(\\frac{E_1-E_0}{\\theta_2})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}=\\frac{1-e^{-(k_1(\\theta_2)*(1-\\eta)*\\pi_c)}}{1-e^{-([k_1(\\theta_1)*\\eta+k_1(\\theta_2)*(1-\\eta)]*\\pi_c)}}\\\\\r\n\\text{with } q=\\frac{1}{\\theta^{*}}+\\frac{1}{\\theta_c}\\text{; }\\theta_1=297K\\text{; }\\theta_2=279K\\text{; }\\eta=\\frac{1}{3}\r\n\\end{align*}\r\n\\]\r\nConverting Parameters\r\nTo convert the intermediate model parameters, you can use the function LarsChill::convert_parameters(). It is written to take all 12 PhenoFlex model parameters, because at the time that was the easiest way for me to implement it. But it only affects the four intermediate model parameters\r\nHere is an example\r\n\r\n\r\n#       yc   zc   s1   Tu  theta_star theta_c tau  pie_cTf Tu Tb slope\r\npar <- c(40, 190, 0.5, 25,  281,      287,     30, 24,  4, 36,  4,  1.60)\r\nLarsChill::convert_parameters(par)\r\n\r\n [1] 4.000000e+01 1.900000e+02 5.000000e-01 2.500000e+01 4.457844e+03\r\n [6] 1.016131e+04 4.197532e+05 1.793094e+14 4.000000e+00 3.600000e+01\r\n[11] 4.000000e+00 1.600000e+00\r\n\r\nLuckily, this is also what Fishman et al. (1987b) calculated for these sets of intermediate parameters, so it seems that the function is working alright (if you want to compare, check first row of Table 1, Fishman et al. (1987b)).\r\nBecause A0 and A1 get estimated using an optimization problem, it could theoretically happen that the optimization algorithm fails or that no solution is available. This can be problematic inside an optimization algorithm, so I included options how to handle such a failure to converge. Check details of the failure_return argument.\r\nAdjusting the Wrapper Function for intermediate parameters\r\nYou need to adjust the evaluation functions if you want to use the intermediate model parameters in your optimization problem. Conveniently, PhenoFlex was coded in a modular way, so that evaluation functions can be modified. Inconveniently, PhenoFlex has a quite nested code structure, so that it is at first a bit challenging to find out what exactly needs to be adjusted. The argument modelfn of the phenologyFitter() function controls the function, that calculates bloom dates based on the supplied temperature data and parameters. If we want to exchange the \\(E_0\\) to \\(A_1\\) parameters with the intermediate ones, adjusting the input of the modelfn argument is the way to go.\r\n\r\n\r\nchillR::PhenoFlex_GDHwrapper\r\n\r\nfunction (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n<bytecode: 0x0000014e96739d10>\r\n<environment: namespace:chillR>\r\n\r\nAs you can see, the PhenoFlex_GDHwrapper wrapper is a relatively simple funciton. It takes x and par as inputs. x should be of the same format as tge output of the chillR::genSeasonList() function, it produces a list of data.frames, each data.frame has three columns: ‘Temp’, ‘JDay’ and ‘Year’. par is a numeric vector with twelve entries, containing the PhenoFlex model parameters. Pay attention, that the order of parameters is correct, otherwise the function may not work or produce funny results. The first par of the code ensures that temperatures of the heat submodel make sense, the base temperature \\(T_b\\) must be lower than optimal temperature \\(T_u\\) and secondly, \\(T_u\\) should not be larger than the critical temperature \\(T_c\\). The next part of the code inserts the model parameters and the temperature data into PhenoFlex. PhenoFlex returns the bloomindex, this is not the bloom date but indicates at which row of the temperature data.frame x the accumulated heat exceeds the heat requirement \\(z_c\\). The last part of the code calculates the bloom date, it has a routine what to do when the accumulated heat never exceeds \\(z_c\\) (it returns an NA to the phenologyFitter() function) or it calculates the Julian Day (with digits). The bloom date calculation looks at first glance a bit complicated, but it accounts for the hour when the requirement is met. When it is met at noon at 12:00, it returns the Julian Day without alteration. If it is earlier, it subtracts a fraction and if it is later than noon it adds a fraction.\r\nHere is an example with intermediate model parameters:\r\n\r\n\r\nPhenoFlex_GDHwrapper_adjusted <- function (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n  \r\n  #convert bloom dates\r\n  par_converted <- LarsChill::convert_parameters(par)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par_converted[1], zc = par_converted[2], s1 = par_converted[3], Tu = par_converted[4], E0 = par_converted[5], \r\n        E1 = par_converted[6], A0 = par_converted[7], A1 = par_converted[8], Tf = par_converted[9], Tc = par_converted[10], \r\n        Tb = par_converted[11], slope = par_converted[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nDownside of this approach is, that the conversion happens for each bloom date calculation seperately. But it would be necissary to convert it once and then calculate bloom dates for all the SeasonList entries. Unfortunately, the modelfn argument is the only way to customize the functions without having to build a whole custom version of phenologyFitter() function. I address this shortcoming in the chapter on customized model calibration.\r\n\r\n\r\n\r\nCaspersen, L., Schiffers, K., Picornell, A., Egea, J.A., Delgado, A., El Yaacoubi, A., Benmoussa, H., Rodrigo, J., Fadón, E., Ben Mimoun, M., Ghrab, M., Kodad, O., Ruiz, D., Luedeling, E., 2025. Contrasting Responses to Climate Change – Predicting Bloom of Major Temperate Fruit Tree Species in the Mediterranean Region and Central Europe. https://doi.org/10.2139/ssrn.5106075\r\n\r\n\r\nEgea, J.A., Egea, J., Ruiz, D., 2021. Reducing the uncertainty on chilling requirements for endodormancy breaking of temperate fruits by data-based parameter estimation of the dynamic model: A test case in apricot. Tree Physiology 41, 644–656. https://doi.org/10.1093/treephys/tpaa054\r\n\r\n\r\nFernandez, E., Schiffers, K., Urbach, C., Luedeling, E., 2022. Unusually warm winter seasons may compromise the performance of current phenology models – Predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology 322, 109020. https://doi.org/10.1016/j.agrformet.2022.109020\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987a. The temperature-dependence of dormancy breaking in plants - computer-simulation of processes studied under controlled temperatures. Journal of Theoretical Biology 126, 309–321. https://doi.org/10.1016/s0022-5193(87)80237-0\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987b. The temperature dependence of dormancy breaking in plants: Mathematical analysis of a two-step model involving a cooperative transition. Journal of Theoretical Biology 124, 473–483. https://doi.org/10.1016/S0022-5193(87)80221-7\r\n\r\n\r\nLuedeling, E., Caspersen, L., Delgado, A., Egea, J.A., Ruiz, D., Ben Mimoun, M., Benmoussa, H., Ghrab, M., Kodad, O., El Yaacoubi, A., Fadón, E., Rodrigo, J., 2024. Long-term phenology observations for temperate fruit trees in the Mediterranean region (and Germany).\r\n\r\n\r\nLuedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical Methods for Phenology Analysis in Temperate Fruit Trees.\r\n\r\n\r\nLuedeling, E., Schiffers, K., Fohrmann, T., Urbach, C., 2021. PhenoFlex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n\r\n\r\nUrbach, C., Luedeling, E., Schiffers, K., 2021. PhenoFlex - vignette within the chillR package.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-27T16:11:48+01:00"
    },
    {
      "path": "overview_custom-model-calibration.html",
      "title": "Overview: Custom Model Calibration",
      "author": [],
      "contents": "\r\nThis part is all about calibrating PhenoFlex. The chillR::phenologyFitter() helps you to estimate model parameters. However, the function may not be ideal your specific situation, for example maybe you want to keep some model parameters fixed, maybe you want to tune PhenoFlex using a different global optimization function, or maybe you want to make more substantial changes to PhenoFlex, add additional parameters to the model, pool certain model parameters across cultivars of the same species or maybe you want to model a sequence of phenological events within one model.\r\nHere, I collected all of the different adjustments you may want to make when calibrating PhenoFlex:\r\nfix model parameters\r\nreplace chill submodel-parameters with intermediate, well-defined parameters\r\nuse another calibration algorithm, at the example of Enhanced Scatter Search of the MEIGO R-package\r\ncombined fitting: sharing chill and heat submodel parameters across cultivars of same species while having cultivar-specific requirement and transition parameters\r\nmodel sequence of phenology events in one model\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-27T16:06:21+01:00"
    },
    {
      "path": "start.html",
      "title": "Working with PhenoFlex - Lars Edition",
      "author": [],
      "contents": "\r\nPhenoFlex is a phenology model (Luedeling et al., 2021), accessible via the chillR package (Luedeling et al., 2023). During my PhD I mainly worked with PhenoFlex and worked out custimized functions. These functions made it easier for me to work with PhenoFlex, for example to integrate different calibration methods, calibration algortihms or to fit several phenological stages in one go.\r\nThe standard PhenoFlex routines, from running the model, calibrating it, cross-validation and plotting the outputs of the chill and heat accumulation submodels is already nicely documented by Urbach et al. (2021), see https://cran.r-project.org/web/packages/chillR/vignettes/PhenoFlex.html. These routines were the blueprint for the first phenology studies using PhenoFlex (Fernandez et al., 2022; Luedeling et al., 2021).\r\nIn these studies, many iterations of model calibration were carried out. That means you run the calibration fitting function chillR::PhenologyFitter(), wait and check if the estimated model parameters provide better predictions, if yes, then you start another round of calibration, using the estimated parameters as a new starting point. If they did not improve the predictions, you may want to change the search space, either make them wider or narrower to help the optimization algorithm to find new sets of parameters. 15 to 30 rounds of iterations were used to find the final set of parameters. This workflow resulted in fairly good parameters, the validation RMSE was below 4 days in these studies, however, it is a lot of work and takes quite a while. And most importantly, it is difficult to scale up the process, because it involves a lot of manual checking, adjusting search ranges, checking temperature response plots.\r\nOne of my first tasks as a PhD was to apply PhenoFlex to an extensive phenology dataset assembled in the Adapting Mediterranean Orchards (AdaMedOr) project (Luedeling et al., 2024). The dataset comprised 270 cultivars of seven temperate fruit tree species (almond, pistachio, apple, pear, plum, sweet cherry, apricot). More than 100 cultivars had 20 or more observations (Caspersen et al., 2025), which is deemed to be the critical number of observations for model calibration (Urbach et al., 2021). For most of the cultivars we had 20 observations, so after a 75% calibration - 25% validation split only 5 observations are in the validation data set. Validating the model only on 5 observations seems quite a stretch, so we wanted to cross-validate the calibrated the model, so we had to even do more calibration steps.\r\nIntermediate chill submodel parameters\r\nTogether with Jose Egea, member of the AdaMedOr project consortium and experienced in global optimization problems, we hypothesized that part of the calibration problem are the ranges of the model parameters. In particular the parameters controlling the chill submodel. The Dynamic Model (Fishman et al., 1987a, 1987b) consists of two ordinary differential equation (ODE) modeling the build-up and degradation of some (hypothetical) precursor of a dormancy breaking factor (PDBF). After a critical amount of PDBF is accumulated, a certain share gets converted to a non-degradable dormancy breaking factor (DBF). For the ODEs controlling build-up and degradation of PDBF four parameters are needed: \\(E_0\\): activation energy for forming PDBF, \\(A_0\\): amplitude of the formation process, \\(E_1\\): activation energy for degrading PDBF and \\(A_1\\): amplitude of the degradation process. All of these parameters are not really tangible for most people, so setting boundaries is difficult. It is even more difficult, because the default value of \\(A_1\\) for example is on a ridiculous scale, 5.939917e13, that is a number wit 13 zeros before the digit! Good luck finding an appropriate search space that does not limit the algorithm too much but still is manageable. By the way, the default search space in Urbach et al. (2021) might be too narrow, as in the original paper describing the Dynamic Model parameter they ranged from 0.1797e15 to 0.1875e17, while there the search space is “only” between 5.e13 to 6.e13. Also, they had initially ridiculous ranges in the other estimated model parameters, for instance \\(A_0\\) ranged from 0.1386e4 to 0.1405e15. So in summary, finding appropriate ranges for these parameters is a difficult task, and even if you find them, it is a difficult search space for the optimization algorithm to navigate. Based on my limited experience, the optimizer is often “stuck” for these parameters and does not offer different sets of parameters for \\(E_0\\), \\(E_1\\), \\(A_0\\) and \\(A_1\\).\r\nEgea et al. (2021) point out, that the \\(E_0\\) to \\(A_1\\) parameters of the Dynamic Model get actually calculated based on a set of more tangible parameters, describing the experimental set-up, that serves as a basis of the Dynamic Model. These intermediate parameters are according to Fishman et al. (1987b): \\(\\theta^{*}\\): the temperature, leading to a maximal chilling effect, \\(\\theta_c\\) the highest temperature which still gives a positive response, \\(\\tau\\): the time needed to accumulate one critical portion of DBF under optimal temperature conditions and \\(\\pi_c\\) and the length of the cycle in a two-temperature regime, which leads to complete chilling negation.\r\nOther parameters describing the experiment, include the alternated temperatures of the experiment (\\(\\theta_1=297K\\), \\(\\theta_2=279K\\)), and the fixed relation of these two temperatures (\\(\\eta = \\frac{1}{3}\\)). The \\(E_0\\) to \\(A_1\\) parameters get estimated on \\(\\theta^{*}\\), \\(\\theta_c\\), \\(\\tau\\) and \\(\\pi_c\\) So Egea et al. (2021) proposed run a global optimization procedure on the intermediate parameters instead, because they are measured in Kelvin and hours, and boundaries of the search space are easier to set. Unfortunately, this involved to dig through some nasty looking equations, check out Egea et al. (2021) and the original publication of the Dynamic Model, equations 33 to 38 (Fishman et al., 1987b). In the end, a clean conversion is not possible for \\(A_1\\) and \\(A_0\\), they need to be estimated using an optimization problem.\r\nHere is the set of equations that need to be solved (taken from Egea et al. (2021)):\r\n\\[\r\n\\begin{align*}\r\nE_1=\\frac{E_0-E_1}{e^{(E_1-E_0)*q}-1}*\\frac{1}{ln(1-e^{(E_0-E1)*q})}\\\\\r\nA_1=-e^{\\frac{E_1}{\\theta^{*}}}*\\frac{ln(1-e^{(E_0-E_1)*q})}{\\tau}\\\\\r\nA_0=A_1e^{(\\frac{E_0-E_1}{\\theta_c})}\\\\\r\n\\frac{e^{(\\frac{E_1-E_0}{\\theta_c})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}{e^{(\\frac{E_1-E_0}{\\theta_2})}-e^{(\\frac{E_1-E_0}{\\theta_1})}}=\\frac{1-e^{-(k_1(\\theta_2)*(1-\\eta)*\\pi_c)}}{1-e^{-([k_1(\\theta_1)*\\eta+k_1(\\theta_2)*(1-\\eta)]*\\pi_c)}}\\\\\r\n\\text{with } q=\\frac{1}{\\theta^{*}}+\\frac{1}{\\theta_c}\\text{; }\\theta_1=297K\\text{; }\\theta_2=279K\\text{; }\\eta=\\frac{1}{3}\r\n\\end{align*}\r\n\\]\r\nTo convert the intermediate model parameters, you can use the function LarsChill::convert_parameters(). It is written to take all 12 PhenoFlex model parameters, because at the time that was the easiest way for me to implement it. But it only affects the four intermediate model parameters\r\nHere is an example\r\n\r\n\r\n#       yc   zc   s1   Tu  theta_star theta_c tau  pie_cTf Tu Tb slope\r\npar <- c(40, 190, 0.5, 25,  281,      287,     30, 24,  4, 36,  4,  1.60)\r\nLarsChill::convert_parameters(par)\r\n\r\n [1] 4.000000e+01 1.900000e+02 5.000000e-01 2.500000e+01 4.457844e+03\r\n [6] 1.016131e+04 4.197532e+05 1.793094e+14 4.000000e+00 3.600000e+01\r\n[11] 4.000000e+00 1.600000e+00\r\n\r\nLuckily, this is also what Fishman et al. (1987b) calculated for these sets of intermediate parameters, so it seems that the function is working alright (if you want to compare, check first row of Table 1, Fishman et al. (1987b)).\r\nBecause A0 and A1 get estimated using an optimization problem, it could theoretically happen that the optimization algorithm fails or that no solution is available. This can be problematic inside an optimization algorithm, so I included options how to handle such a failure to converge. Check details of the failure_return argument.\r\nYou need to adjust the evaluation functions if you want to use the intermediate model parameters in your optimization problem. Conveniently, PhenoFlex was coded in a modular way, so that evaluation functions can be modified. Inconveniently, PhenoFlex has a quite nested code structure, so that it is at first a bit challenging to find out what exactly needs to be adjusted. The argument modelfn of the phenologyFitter() function controls the function, that calculates bloom dates based on the supplied temperature data and parameters. If we want to exchange the \\(E_0\\) to \\(A_1\\) parameters with the intermediate ones, adjusting the input of the modelfn argument is the way to go.\r\n\r\n\r\nchillR::PhenoFlex_GDHwrapper\r\n\r\nfunction (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n<bytecode: 0x0000021111f03c30>\r\n<environment: namespace:chillR>\r\n\r\nAs you can see, the PhenoFlex_GDHwrapper wrapper is a relatively simple funciton. It takes x and par as inputs. x should be of the same format as tge output of the chillR::genSeasonList() function, it produces a list of data.frames, each data.frame has three columns: ‘Temp’, ‘JDay’ and ‘Year’. par is a numeric vector with twelve entries, containing the PhenoFlex model parameters. Pay attention, that the order of parameters is correct, otherwise the function may not work or produce funny results. The first par of the code ensures that temperatures of the heat submodel make sense, the base temperature \\(T_b\\) must be lower than optimal temperature \\(T_u\\) and secondly, \\(T_u\\) should not be larger than the critical temperature \\(T_c\\). The next part of the code inserts the model parameters and the temperature data into PhenoFlex. PhenoFlex returns the bloomindex, this is not the bloom date but indicates at which row of the temperature data.frame x the accumulated heat exceeds the heat requirement \\(z_c\\). The last part of the code calculates the bloom date, it has a routine what to do when the accumulated heat never exceeds \\(z_c\\) (it returns an NA to the phenologyFitter() function) or it calculates the Julian Day (with digits). The bloom date calculation looks at first glance a bit complicated, but it accounts for the hour when the requirement is met. When it is met at noon at 12:00, it returns the Julian Day without alteration. If it is earlier, it subtracts a fraction and if it is later than noon it adds a fraction.\r\nHere is an example with intermediate model parameters:\r\n\r\n\r\nPhenoFlex_GDHwrapper_adjusted <- function (x, par) \r\n{\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n  \r\n  #convert bloom dates\r\n  par_converted <- LarsChill::convert_parameters(par)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par_converted[1], zc = par_converted[2], s1 = par_converted[3], Tu = par_converted[4], E0 = par_converted[5], \r\n        E1 = par_converted[6], A0 = par_converted[7], A1 = par_converted[8], Tf = par_converted[9], Tc = par_converted[10], \r\n        Tb = par_converted[11], slope = par_converted[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nDownside of this approach is, that the conversion happens for each bloom date calculation seperately. But it would be necissary to convert it once and then calculate bloom dates for all the SeasonList entries. Unfortunately, the modelfn argument is the only way to customize the functions without having to build a whole custom version of phenologyFitter() function. I address this shortcoming in the chapter on customized model calibration.\r\nIntermediate chill submodel parameters\r\nAdjusting the GDH-wrapper function is also the easiest way to fix model parameters. Here is an example with \\(T_c\\) fixed at 36°C. Now par should have only 11 entries, because we fixed Tc. Pay attention, that you incert the fixed parameters at the right position or correct the indices in the later code, so that the parameters are assigned correctly in the PhenoFlex function call. You can of course fix more model parameters, if you want to. Also, make sure that you remove the fixed parameter from par.guess and the search ranges when running the phenologyFitter() function.\r\n\r\n\r\nPhenoFlex_GDHwrapper_fixed <- function (x, par, Tc = 36) \r\n{\r\n  par <- c(par[1:9], Tc, par[10:11])\r\n    if (par[4] <= par[11]) \r\n        return(NA)\r\n    if (par[10] <= par[4]) \r\n        return(NA)\r\n    bloomindex <- PhenoFlex(temp = x$Temp, times = seq_along(x$Temp), \r\n        yc = par[1], zc = par[2], s1 = par[3], Tu = par[4], E0 = par[5], \r\n        E1 = par[6], A0 = par[7], A1 = par[8], Tf = par[9], Tc = par[10], \r\n        Tb = par[11], slope = par[12], Imodel = 0L, basic_output = TRUE)$bloomindex\r\n    if (bloomindex == 0) \r\n        return(NA)\r\n    JDay <- x$JDay[bloomindex]\r\n    JDaylist <- which(x$JDay == JDay)\r\n    n <- length(JDaylist)\r\n    if (n == 1) \r\n        return(JDay)\r\n    return(JDay + which(JDaylist == bloomindex)/n - 1/(n/ceiling(n/2)))\r\n}\r\n\r\n\r\nAlternative optimization algorithm MEIGO with additional parameter constraints\r\nAs you can see, customizing the evaluation function is relatively simple. It gets a bit more complicated when you want to try out a different optimization algorithm than the simulated annealing function, implemented in the phenologyFitter() function. For example, I wanted to use the optimization framework MEIGO (Egea et al., 2014). MEIGO is also available on bioconductor, a platform where you can access R packages similar to CRAN. The installation via bioconductor is in my opinion less convenient than via CRAN and installing MEIGOR package was error-prone. As a quick fix, I mirrored the core of the MEIGOR package in my custom R package LarsChill (quite an original name, I know) https://github.com/larscaspersen/addition_chillR. Here you can find the original vignette for MEIGOR: https://www.bioconductor.org/packages/release/bioc/manuals/MEIGOR/man/MEIGOR.pdf. I only took the function for the Enhanced Scatter Search (ESS), which you can find via LarsChill::custom_essr(), but the functionality is just the same as in the original MEIGOR package.\r\nThe ESS has some advantages and disadvantages compared to the simulated annealing algorithm. It was developed for complex optimization problems, it allows to screen for many different sets of model parameters, something I had the feeling the standard phenologyFitter() function was lacking. It is also relatively fast for small datasets (with <100 observations). You can specify additional inequality constraints when setting up the optimization problem. As you saw in the previous example, also the GDH_wrapper has some additional constraints implemented, but MEIGOR makes these easier to detect and to adjust and it also allows to specify acceptable ranges. I also like, that the function returns all the intermediate solutions that were surpassed by other sets of parameters in the course of the optimization run, it also returns the intermediate error scores, convenient if you want to make sure that the algorithm has converged or not. A big disadvantage is, that the speed of the ESS algorithm deteriorates quite fast for larger datasets, so if you have lots of observations in the calibration dataset it is better to stick with the simulated annealing algorithm used in the phenologyFitter function.\r\nTo optimize PhenoFlex with another algorithm involves a little bit more work. The ESS optimization algorithm needs a function that calculates the model error for a particular set of parameters and temperature data. In most optimization problems model error is measured as Residual Sum of Squares (RSS), which is in our case simply the sum of the squared differences between predicted and observed bloom dates. The PhenoFlex_GDH_wrapper() function, however, only returns the bloom date for one season of temperatures and it does not even compare the prediction to the observed bloom dates. The function taking care of calculating the RSS is a hidden function called chillR:::chifull(). Note that I used three colons, when referring to the function, because this notation allows to access “hidden” functions, that did not get exported when creating the chillR package.\r\nI decided to maintain the modular structure of the phenologyFitter() function, where you specify the function how to calculate a bloom date with the modelfn argument, like with the PhenoFlex_GDH_wrapper() function. The evaluation function needs to do three things:\r\ncalculate bloom dates based on the temperature data specifeid in SeasonList\r\ncalculate RSS by comparing the predicted bloom dates with the observed ones, specified in bloomJDays\r\ncheck model parameters for additional constraints\r\nHere is an example of an evaluation function, that is compatible with the ESS algorithm of MEIGOR. I tried to\r\nbundle all the different cusotm evaluaiton functions and wrapper functions in a seperate package called\r\nevalpheno, you can find the package here: https://github.com/larscaspersen/eval_phenoflex\r\n\r\n\r\nevalpheno::evaluation_function_meigo\r\n\r\nfunction (x, modelfn, bloomJDays, SeasonList, na_penalty = 365) \r\n{\r\n    par <- x\r\n    pred_bloom <- unlist(lapply(X = SeasonList, FUN = modelfn, \r\n        par = par))\r\n    pred_bloom <- ifelse(is.na(pred_bloom), yes = na_penalty, \r\n        no = pred_bloom)\r\n    F <- sum((pred_bloom - bloomJDays)^2)\r\n    g <- rep(0, 5)\r\n    g[1] <- x[4] - x[11]\r\n    g[2] <- x[10] - x[11]\r\n    g[3] <- x[10] - x[4]\r\n    g[4] <- exp((10 * x[5])/(297 * 279))\r\n    g[5] <- exp((10 * x[6])/(297 * 279))\r\n    return(list(F = F, g = g))\r\n}\r\n<bytecode: 0x000002111cc22550>\r\n<environment: namespace:evalpheno>\r\n\r\nAs you can see, the evaluation functions is actually quite simple. At first we predict bloom dates, using the entries of SeasonList, t the function to calculate bloom dates specified in modelfn and the parameters specified in x(in the vignette for the MEIGOR package they always called the vector of the parameter x, while in PhenoFlex it is the name for the temperature data. Because I was not sure if the naming affected something, I followed the naming convention of the vignette, though it might be confusing.).\r\nIn case there is an NA in the predicted bloom dates, the value gets replaced with a value specified in na_penalty. Next, predicted and observed bloom dates get compared and the RSS is calculated and saved in the object F. The last and longest part is about the inequality constraints. The first three of the constrains should be familiar, as they are the same as in the PhemoFlex_GDH_wapper() function. Constrains 4 and 5 are new, relate to the \\(Q_{10}\\) metric, that expresses by which factor a biological process speeds up for an increase in temperature by 10°C (Hegarty, 1973). In biological systems \\(Q_{10}\\) values of 1.5 to 3.5 are deemed realisitic (Egea et al., 2021). In the early PhenoFlex papers (Fernandez et al., 2022; Luedeling et al., 2021) the \\(Q_{10}\\) metric was checked after the calibration, but I think it makes even more sense to check the metric during the calibration. The results of the inequality constraints get saved in the vector g. Both, the error function F and the results of the inequality constrains g get returned to the optimization function.\r\nBefore running the optimization function, we can specify acceptable upper and lower ranges for the inequality constrains, similar to how you do it for the search space of the model parameters.\r\nHere is an example of the specifications I made when calibrating PhenoFlex for a large dataset of temperate fruit trees (Caspersen et al., 2025):\r\n\r\n\r\n#search space of model parameters\r\n#        yc      zc     s1      Tu      theta_c   tau      piec    Tf     Tb     slope\r\nx_0 <- c(24.79,  337.04,  0.2529,  17.72,  285.54,     45.67,    29.49,  2.97,  1.87,  2.69)\r\nx_U <- c(80,    500,    1.0,    30,     287,       48,      50,    10,    10,     5.00)\r\nx_L <- c(20,    100,    0.1,    15,     284,       16,      24,     2,     2,     1.2)\r\n\r\n#limits for the inequality constraints\r\n#         #gdh parameters   #q10 for E0 and E1\r\nc_L <- c(  0,   0,   0,     1.5, 1.5)\r\nc_U <- c(Inf, Inf, Inf,     3.5, 3.5)\r\n\r\nproblem<-list(f=\"evalpheno::eval_phenoflex_single_twofixed\",\r\n              x_0 = x_0,\r\n              x_L = x_L,\r\n              x_U = x_U,\r\n              c_L = c_L, \r\n              c_U = c_U)\r\n\r\n\r\n#options for fitter\r\nopts<-list(#maxeval = 1000,\r\n  maxtime = 60 * 10, \r\n  local_solver = 'DHC', \r\n  local_bestx = 1)\r\n\r\nLarsChill::custom_essr(problem = problem,\r\n                       opts = options,\r\n                       modelfn = custom_PhenoFlex_GDHwrapper,\r\n                       bloomJDays = pheno,\r\n                       SeasonList = season_cal_list)\r\n\r\n\r\nThe first part is about the search space of the model parameters. I decided to optimize based on the intermediate model parameters and to fix two of the model parameters (\\(\\theta^{*} = 279\\), \\(T_c=36\\)). x_0 is the initial guess, x_L the lower search range and x_U the upper range. The upper acceptable limit of the inequality constrain is specified in c_U and the lower limit in c_L. In the first three constrains for the heat submodel temperature parameters, we excluded any negative value, in the last two relating to the \\(Q_{10}\\) metric, we excluded values outside the range of 1.5 to 3.5. All of that information is bundled in a list called problem. There it is also specified which evaluation function we are using, here I use the function evalpheno::eval_phenoflex_single_twofixed. Make sure that you omit the paranthesis after function name, because you want to only specify the name and not exexcute the function. The problem-list gets followed by the option list, here you specify settings of the optimization algorithm. maxtime specifies the time-limit for how long the algortihm should optimize (in seconds). local_solver specifies which optimization algorithm should be run when ESS found a set of model parameter leading to a lower RSS. The local solver makes a more refined narrower search around the newly found, better model parameters. local_bestx specifies how often the local search is called. When set to 1, local search is only triggered immediately after a better set is found, higher values would postpone the local search for some further iterations, that can be beneficial when the global search quickly finds even better parameter sets. You can also specifiy how many iterations the algorithms should make with maxeval. For more options, check the MEIGOR vignette.\r\nLastly, the problem and option list get supplied to the LarsChill::custom_essr() funciton. This function does the optimization and should hopefully return good model parameters for your dataset. As you may have noticed, I also supplied three further arguments to the function: modelfn, bloomJDays and SeasonList. These are inputs for the evaluation function specified in the problem list. They are the same when running the phenologyFitter() function.\r\nShared chill and heat accumulation submodels but cultivar-specific requirement parameters: The combined fitting approach\r\n\r\n\r\n\r\nCaspersen, L., Schiffers, K., Picornell, A., Egea, J.A., Delgado, A., El Yaacoubi, A., Benmoussa, H., Rodrigo, J., Fadón, E., Ben Mimoun, M., Ghrab, M., Kodad, O., Ruiz, D., Luedeling, E., 2025. Contrasting Responses to Climate Change – Predicting Bloom of Major Temperate Fruit Tree Species in the Mediterranean Region and Central Europe. https://doi.org/10.2139/ssrn.5106075\r\n\r\n\r\nEgea, J.A., Egea, J., Ruiz, D., 2021. Reducing the uncertainty on chilling requirements for endodormancy breaking of temperate fruits by data-based parameter estimation of the dynamic model: A test case in apricot. Tree Physiology 41, 644–656. https://doi.org/10.1093/treephys/tpaa054\r\n\r\n\r\nEgea, J.A., Henriques, D., Cokelaer, T., Villaverde, A.F., MacNamara, A., Danciu, D.-P., Banga, J.R., Saez-Rodriguez, J., 2014. MEIGO: An open-source software suite based on metaheuristics for global optimization in systems biology and bioinformatics. BMC Bioinformatics 15, 136. https://doi.org/10.1186/1471-2105-15-136\r\n\r\n\r\nFernandez, E., Schiffers, K., Urbach, C., Luedeling, E., 2022. Unusually warm winter seasons may compromise the performance of current phenology models – Predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology 322, 109020. https://doi.org/10.1016/j.agrformet.2022.109020\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987a. The temperature-dependence of dormancy breaking in plants - computer-simulation of processes studied under controlled temperatures. Journal of Theoretical Biology 126, 309–321. https://doi.org/10.1016/s0022-5193(87)80237-0\r\n\r\n\r\nFishman, S., Erez, A., Couvillon, G.A., 1987b. The temperature dependence of dormancy breaking in plants: Mathematical analysis of a two-step model involving a cooperative transition. Journal of Theoretical Biology 124, 473–483. https://doi.org/10.1016/S0022-5193(87)80221-7\r\n\r\n\r\nHegarty, T.W., 1973. Temperature Coefficient (Q10), Seed Germination and Other Biological Processes. Nature 243, 305–306. https://doi.org/10.1038/243305a0\r\n\r\n\r\nLuedeling, E., Caspersen, L., Delgado, A., Egea, J.A., Ruiz, D., Ben Mimoun, M., Benmoussa, H., Ghrab, M., Kodad, O., El Yaacoubi, A., Fadón, E., Rodrigo, J., 2024. Long-term phenology observations for temperate fruit trees in the Mediterranean region (and Germany).\r\n\r\n\r\nLuedeling, E., Caspersen, L., Fernandez, E., 2023. chillR: Statistical Methods for Phenology Analysis in Temperate Fruit Trees.\r\n\r\n\r\nLuedeling, E., Schiffers, K., Fohrmann, T., Urbach, C., 2021. PhenoFlex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology 307, 108491. https://doi.org/10.1016/j.agrformet.2021.108491\r\n\r\n\r\nUrbach, C., Luedeling, E., Schiffers, K., 2021. PhenoFlex - vignette within the chillR package.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2025-03-27T15:39:27+01:00"
    }
  ],
  "collections": []
}
